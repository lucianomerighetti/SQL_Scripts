/*
AUTOMATIZACAO DE SCRIPT DE MOVES -- MOVERA SEGMENTOS DE UMA TABELA QUE ESTEJA EM DETERMINADA ALOCACAO DA TABLESPACES
*/

SET SERVEROUTPUT ON SIZE UNLIMITED
EXEC DBMS_OUTPUT.ENABLE (buffer_size => NULL);
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';

DECLARE

  P_TABLE VARCHAR2(4000) := 'CASHOUT'; -- NOME DA TABELA DA OPERACAO
  P_TSDORIG VARCHAR2(4000) := 'TSDRECEIVABLES01'; -- TABLESPACE DE DADOS ORIGEM
  P_TSIORIG VARCHAR2(4000) := 'TSIRECEIVABLES01'; -- TABLESPACE DE INDICE ORIGEM
  P_TSLORIG VARCHAR2(4000) := 'TSLRECEIVABLES01'; -- TABLESPACE DE LOB ORIGEM   
  P_TSDDEST VARCHAR2(4000) := 'TSDRECEIVABLES02'; -- TABLESPACE DE DADOS DESTINO
  P_TSIDEST VARCHAR2(4000) := 'TSIRECEIVABLES02'; -- TABLESPACE DE INDICE DESTINO
  P_TSLDEST VARCHAR2(4000) := 'TSLRECEIVABLES01'; -- TABLESPACE DE LOB DESTINO 
  P_MOVE_INDEX CHAR(1) := 'S'; -- VERIFICA SE HAVERA MOVE DE INDICE  
  P_MOVE_LOB   CHAR(1) := 'S'; -- VERIFICA SE HAVERA MOVE DE LOB    
  P_PARALLEL  NUMBER(2) := 12; -- VALOR DO PARALELISMO
  P_ONLINE  CHAR(1) := 'N'; -- SE FOR UMA ATIVIDADE ONLINE, COLOQUE 'S', SE NAO,'N'
  P_COMPRESS CHAR(1) := 'S'; -- SE TIVER COMPRESSAO COLOQUE 'S', SE NAO,'N' 
  P_UPDATE_INDEX CHAR(1) := 'N'; -- SE TIVER UPDATE INDEX COLOQUE 'S', SE NAO,'N' 
  P_DISABLE_FK CHAR(1) := 'S'; -- OPCAO DE DESATIVAR FKS
  P_COLLECT_STATS CHAR(1) := 'S'; -- OPCAO DE COLETAR ESTATISTICAS APOS OS MOVES
  P_DAT_CORTE_COMPRESS  DATE := '2023-01-01'; -- CASO A COMPRESSAO SEJA SOMENTE DE UM PERIODO DE DADOS
  P_TAM_GB NUMBER(4) := 100; -- O TAMANHO ALOCADO QUE VOCE QUER QUE CHEGUE A TABLESPACE DE DADOS
  
  
  V_OWNER VARCHAR2(100) := SUBSTR(SYS_CONTEXT('USERENV','DB_NAME'),4,50)||'_ADM';  
  V_INCOMING    VARCHAR2(32767);
  V_DAT_PART  DATE;
  V_MOVE_TAB VARCHAR2(4000);
  V_MOVE_IND VARCHAR2(4000);
  V_MOVE_LOB VARCHAR2(4000);  
  V_REBUILD_IND VARCHAR2(4000);
  V_COLLECT_TAB VARCHAR2(4000);
  V_COLLECT_IND VARCHAR2(4000);
  V_DEF_TSD VARCHAR(4000);
  V_DEF_TSI VARCHAR(4000);
  V_DEF_TSL VARCHAR(4000);  
  V_DISABLE_FK VARCHAR(4000);  
  V_ENABLE_FK VARCHAR(4000);    
  V_PARAMS VARCHAR(4000);  
  V_PARAM_COMPRESS VARCHAR2(4000);
  V_PARAM_UPDATE_INDEX VARCHAR2(4000);  


-- Busca segmentos da tabela dentro do range estipulado da tablespace
CURSOR C_SEGMENTS_TS IS
  SELECT DISTINCT E.OWNER AS SEGMENT_OWNER
                , E.SEGMENT_TYPE
                , E.SEGMENT_NAME
                , NVL(E.PARTITION_NAME,'NP') AS PARTITION_NAME
  FROM DBA_EXTENTS E
  WHERE E.FILE_ID IN (SELECT DF.FILE_ID
                      FROM   DBA_DATA_FILES DF
                      WHERE  DF.TABLESPACE_NAME=P_TSDORIG) 
  AND  (E.BLOCK_ID*(SELECT TS.BLOCK_SIZE/1024 
                    FROM DBA_TABLESPACES TS 
                    WHERE TS.TABLESPACE_NAME=P_TSDORIG)+(E.BYTES/1024)) > (P_TAM_GB*1024*1024)
  AND E.SEGMENT_NAME = P_TABLE;

-- Busca dados básicos da tabela
CURSOR C_TABLES (PR_OWNER VARCHAR, PR_TABLE_NAME VARCHAR, PR_PARTITION_NAME VARCHAR) IS
  SELECT T.OWNER  AS TABLE_OWNER	
  	    ,T.TABLE_NAME
  	    ,NVL(S.PARTITION_NAME,'NP') AS PARTITION_NAME
        ,NVL(T.TABLESPACE_NAME,S.TABLESPACE_NAME) AS TABLESPACE_NAME
        ,T.PARTITIONED		
        ,ROUND(NVL(S.BYTES,0)/1024/1024,2) SIZE_MB		
        ,ROUND(NVL(S.BYTES,0)/1024/1024/1024,2) SIZE_GB		
        ,ROUND(NVL(S.BYTES,0)/1024/1024/1024/1024,2) SIZE_TB	
  FROM DBA_TABLES T
  LEFT JOIN DBA_SEGMENTS S		
  ON S.OWNER = T.OWNER 		
  AND S.SEGMENT_NAME = T.TABLE_NAME		
  WHERE T.OWNER = PR_OWNER
  AND T.TABLE_NAME = PR_TABLE_NAME
  AND NVL(S.PARTITION_NAME,'NP') = PR_PARTITION_NAME  
  AND NVL(T.TABLESPACE_NAME,S.TABLESPACE_NAME) = P_TSDORIG
  ORDER BY 5, 7;

-- Busca dados básicos de indices
CURSOR C_INDEXES (PR_OWNER VARCHAR, PR_TABLE_NAME VARCHAR, PR_PARTITION_NAME VARCHAR) IS
  SELECT I.OWNER AS INDEX_OWNER
        ,I.INDEX_NAME
        ,I.TABLE_OWNER
  	    ,I.TABLE_NAME
  	    ,NVL(S.PARTITION_NAME,'NP') AS PARTITION_NAME
        ,NVL(I.TABLESPACE_NAME,S.TABLESPACE_NAME) AS TABLESPACE_NAME
        ,I.PARTITIONED
        ,ROUND(NVL(S.BYTES,0)/1024/1024,2) SIZE_MB		
        ,ROUND(NVL(S.BYTES,0)/1024/1024/1024,2) SIZE_GB		
        ,ROUND(NVL(S.BYTES,0)/1024/1024/1024/1024,2) SIZE_TB	
  FROM DBA_INDEXES I
  LEFT JOIN DBA_SEGMENTS S		
  ON S.OWNER = I.OWNER 		
  AND S.SEGMENT_NAME = I.INDEX_NAME		
  WHERE I.OWNER = PR_OWNER
  AND I.TABLE_NAME = PR_TABLE_NAME
  AND NVL(S.PARTITION_NAME,'NP') = PR_PARTITION_NAME
  AND NVL(I.TABLESPACE_NAME,S.TABLESPACE_NAME) = P_TSIORIG
  ORDER BY I.PARTITIONED DESC, 9;    

-- Busca campos LOB
CURSOR C_LOBS (PR_OWNER VARCHAR, PR_TABLE_NAME VARCHAR, PR_PARTITION_NAME VARCHAR) IS
  SELECT L.OWNER AS LOB_OWNER
        ,L.TABLE_NAME
        ,L.COLUMN_NAME LOB_NAME
  	    ,NVL(S.PARTITION_NAME,'NP') AS PARTITION_NAME		
        ,NVL(L.TABLESPACE_NAME,S.TABLESPACE_NAME) AS TABLESPACE_NAME
        ,L.PARTITIONED
        ,ROUND(NVL(S.BYTES,0)/1024/1024,2) SIZE_MB		
        ,ROUND(NVL(S.BYTES,0)/1024/1024/1024,2) SIZE_GB		
        ,ROUND(NVL(S.BYTES,0)/1024/1024/1024/1024,2) SIZE_TB	
  FROM DBA_TABLES T
  LEFT JOIN DBA_SEGMENTS S		
  ON S.OWNER = T.OWNER 		
  AND S.SEGMENT_NAME = T.TABLE_NAME
  INNER JOIN DBA_LOBS L
  ON S.OWNER = L.OWNER 		
  AND S.SEGMENT_NAME = L.TABLE_NAME
  WHERE L.OWNER = PR_OWNER
  AND L.TABLE_NAME = PR_TABLE_NAME
  AND NVL(S.PARTITION_NAME,'NP') = PR_PARTITION_NAME
  AND NVL(L.TABLESPACE_NAME,S.TABLESPACE_NAME) = P_TSLORIG
  ORDER BY L.PARTITIONED DESC, 8;

-- Busca dados padrao dos objetos particionados da tabela
CURSOR C_DEF_TS_PART IS
  SELECT PT.OWNER OWNER_OBJECT
        ,PT.TABLE_NAME NAME_RELATED
        ,PT.TABLE_NAME NAME_OBJECT
        ,PT.DEF_TABLESPACE_NAME
        ,O.OBJECT_TYPE
  FROM DBA_PART_TABLES PT
  INNER JOIN DBA_OBJECTS O
  ON PT.OWNER = O.OWNER
  AND PT.TABLE_NAME = O.OBJECT_NAME
  WHERE PT.OWNER = V_OWNER
  AND PT.TABLE_NAME = P_TABLE
  AND O.OBJECT_TYPE = 'TABLE'
  UNION
  SELECT PI.OWNER
        ,PI.TABLE_NAME
        ,PI.INDEX_NAME
        ,PI.DEF_TABLESPACE_NAME
        ,O.OBJECT_TYPE
  FROM DBA_PART_INDEXES PI
  INNER JOIN DBA_OBJECTS O
  ON PI.OWNER = O.OWNER
  AND PI.INDEX_NAME = O.OBJECT_NAME
  LEFT JOIN DBA_PART_LOBS PL
  ON PL.TABLE_OWNER = O.OWNER
  AND PL.LOB_INDEX_NAME = O.OBJECT_NAME
  WHERE PI.OWNER = V_OWNER
  AND PI.TABLE_NAME = P_TABLE
  AND O.OBJECT_TYPE = 'INDEX'
  AND PL.LOB_INDEX_NAME IS NULL
  UNION
  SELECT DISTINCT PL.TABLE_OWNER
                 ,PL.TABLE_NAME
                 ,PL.COLUMN_NAME
                 ,PL.DEF_TABLESPACE_NAME
                 ,'LOB'
  FROM DBA_PART_LOBS PL
  INNER JOIN DBA_OBJECTS O
  ON PL.TABLE_OWNER = O.OWNER
  AND PL.TABLE_NAME = O.OBJECT_NAME
  WHERE PL.TABLE_OWNER = V_OWNER
  AND PL.TABLE_NAME = P_TABLE
  AND O.OBJECT_TYPE = 'TABLE';

-- Busca dados padrao dos objetos nao particionados da tabela
CURSOR C_DEF_TS_NO_PART IS
  SELECT T.OWNER OWNER_OBJECT
        ,T.TABLE_NAME NAME_RELATED
        ,T.TABLE_NAME NAME_OBJECT
        ,T.TABLESPACE_NAME
        ,O.OBJECT_TYPE
        ,ROUND(NVL(S.BYTES,0)/1024/1024,2) SIZE_MB		
        ,ROUND(NVL(S.BYTES,0)/1024/1024/1024,2) SIZE_GB		
        ,ROUND(NVL(S.BYTES,0)/1024/1024/1024/1024,2) SIZE_TB	        
  FROM DBA_TABLES T
  INNER JOIN DBA_OBJECTS O
  ON T.OWNER = O.OWNER
  AND T.TABLE_NAME = O.OBJECT_NAME
  INNER JOIN DBA_SEGMENTS S
  ON T.OWNER = S.OWNER
  AND T.TABLE_NAME = S.SEGMENT_NAME  
  WHERE T.OWNER = V_OWNER
  AND T.TABLE_NAME = P_TABLE
  AND O.OBJECT_TYPE = 'TABLE'
  AND T.PARTITIONED = 'NO'
  UNION  
  SELECT I.OWNER
        ,I.TABLE_NAME
        ,I.INDEX_NAME
        ,I.TABLESPACE_NAME
        ,O.OBJECT_TYPE
        ,ROUND(NVL(S.BYTES,0)/1024/1024,2) SIZE_MB		
        ,ROUND(NVL(S.BYTES,0)/1024/1024/1024,2) SIZE_GB		
        ,ROUND(NVL(S.BYTES,0)/1024/1024/1024/1024,2) SIZE_TB	        
  FROM DBA_INDEXES I
  INNER JOIN DBA_OBJECTS O
  ON I.OWNER = O.OWNER
  AND I.INDEX_NAME = O.OBJECT_NAME
  INNER JOIN DBA_SEGMENTS S
  ON I.OWNER = S.OWNER
  AND I.INDEX_NAME = S.SEGMENT_NAME    
  WHERE I.OWNER = V_OWNER
  AND I.TABLE_NAME = P_TABLE
  AND O.OBJECT_TYPE = 'INDEX'
  AND I.PARTITIONED = 'NO'    
  UNION
  SELECT DISTINCT L.OWNER
                 ,L.TABLE_NAME
                 ,L.COLUMN_NAME
                 ,L.TABLESPACE_NAME
                 ,'LOB'
                 ,ROUND(NVL(S.BYTES,0)/1024/1024,2) SIZE_MB		
                 ,ROUND(NVL(S.BYTES,0)/1024/1024/1024,2) SIZE_GB		
                 ,ROUND(NVL(S.BYTES,0)/1024/1024/1024/1024,2) SIZE_TB	        
  FROM DBA_LOBS L
  INNER JOIN DBA_OBJECTS O
  ON L.OWNER = O.OWNER
  AND L.TABLE_NAME = O.OBJECT_NAME
  INNER JOIN DBA_SEGMENTS S
  ON L.OWNER = S.OWNER
  AND L.TABLE_NAME = S.SEGMENT_NAME      
  WHERE L.OWNER = V_OWNER
  AND L.TABLE_NAME = P_TABLE
  AND O.OBJECT_TYPE = 'TABLE'
  AND L.PARTITIONED = 'NO';

-- Busca dados das constraints de relacionamento
CURSOR C_FK IS
  SELECT C.OWNER CONSTRAINT_OWNER
         ,C.TABLE_NAME
         ,C.CONSTRAINT_NAME
         ,LISTAGG(CC.COLUMN_NAME,', ') COLUMNS_NAME
         ,CR.OWNER OWNER_R
         ,CR.TABLE_NAME TABLE_NAME_R
  FROM DBA_CONSTRAINTS C 
  INNER JOIN DBA_CONS_COLUMNS CC
  ON C.OWNER = CC.OWNER
  AND C.TABLE_NAME = CC.TABLE_NAME
  AND C.CONSTRAINT_NAME = CC.CONSTRAINT_NAME
  INNER JOIN DBA_CONSTRAINTS CR
  ON CR.OWNER = C.R_OWNER
  AND CR.CONSTRAINT_NAME = C.R_CONSTRAINT_NAME 
  WHERE C.OWNER = V_OWNER
  AND C.TABLE_NAME = P_TABLE
  AND C.CONSTRAINT_TYPE = 'R'
  GROUP BY C.OWNER
        ,C.TABLE_NAME
        ,C.CONSTRAINT_NAME
        ,CR.OWNER
        ,CR.TABLE_NAME; 


BEGIN 
  
  V_INCOMING := '';
  V_DAT_PART := '';
  V_MOVE_TAB := '';
  V_MOVE_IND := '';
  V_MOVE_LOB := '';
  V_REBUILD_IND := '';
  V_COLLECT_TAB := '';
  V_COLLECT_IND := '';
  V_DEF_TSD := '';
  V_DEF_TSI := '';
  V_DEF_TSL := '';
  V_DISABLE_FK := '';
  V_ENABLE_FK := '';
  V_PARAMS := '';
  V_PARAM_COMPRESS := '';
  V_PARAM_UPDATE_INDEX := '';

  
-- Monta parametros adicionais  
  IF P_COMPRESS = 'S' THEN
    V_PARAM_COMPRESS := ' ROW STORE COMPRESS ADVANCED';
  END IF;
  
  IF P_PARALLEL IS NOT NULL THEN
    V_PARAMS := V_PARAMS||' PARALLEL '||TO_CHAR(P_PARALLEL);  
  END IF;  
  
  IF P_ONLINE = 'S' THEN
    V_PARAMS := V_PARAMS||' ONLINE';
  END IF;
  
  IF V_PARAMS IS NOT NULL THEN
    V_PARAMS := V_PARAMS||';'; 
  END IF;
  
  IF P_UPDATE_INDEX = 'S' THEN
    V_PARAM_UPDATE_INDEX := ' UPDATE INDEXES';
  END IF;
 
  DBMS_OUTPUT.PUT_LINE('SET TIMING ON');	  
  DBMS_OUTPUT.PUT_LINE('ALTER SESSION ENABLE PARALLEL DDL;');	  
  DBMS_OUTPUT.PUT_LINE('');	    
  
  
  -- ALTERA A TABLESPACE PADRAO PARA A TABLESPACE DE DESTINO DOS OBJETOS PARTICIONADOS DA TABELA
  FOR R4 IN C_DEF_TS_PART LOOP
  
    IF R4.OBJECT_TYPE = 'TABLE' THEN

      V_DEF_TSD := 'ALTER TABLE '||R4.OWNER_OBJECT||'.'||R4.NAME_OBJECT||' MODIFY DEFAULT ATTRIBUTES TABLESPACE '||NVL(P_TSDDEST,R4.DEF_TABLESPACE_NAME)||';';
      DBMS_OUTPUT.PUT_LINE(V_DEF_TSD);	

    ELSIF R4.OBJECT_TYPE = 'INDEX' AND P_MOVE_INDEX = 'S' THEN

      V_DEF_TSI := 'ALTER INDEX '||R4.OWNER_OBJECT||'.'||R4.NAME_OBJECT||' MODIFY DEFAULT ATTRIBUTES TABLESPACE '||NVL(P_TSIDEST,R4.DEF_TABLESPACE_NAME)||';';
      DBMS_OUTPUT.PUT_LINE(V_DEF_TSI);	

	ELSIF R4.OBJECT_TYPE = 'LOB' AND P_MOVE_LOB = 'S' THEN

      V_DEF_TSL := 'ALTER TABLE '||R4.OWNER_OBJECT||'.'||R4.NAME_RELATED||' MODIFY DEFAULT ATTRIBUTES LOB ('|| R4.NAME_OBJECT ||') (TABLESPACE '||NVL(P_TSLDEST,R4.DEF_TABLESPACE_NAME)||') ROW STORE COMPRESS ADVANCED;';
	  DBMS_OUTPUT.PUT_LINE(V_DEF_TSL);	
	
	END IF;

  END LOOP;

  DBMS_OUTPUT.PUT_LINE('');
	
  -- DESATIVA FKS
  IF P_DISABLE_FK = 'S' THEN
  
    FOR R5 IN C_FK LOOP
	
	  V_DISABLE_FK := 'ALTER TABLE '||R5.CONSTRAINT_OWNER||'.'||R5.TABLE_NAME||' DROP CONSTRAINT ' || R5.CONSTRAINT_NAME||';';

	  DBMS_OUTPUT.PUT_LINE(V_DISABLE_FK);	
	  
	END LOOP;
  
  END IF;  

  DBMS_OUTPUT.PUT_LINE('');
    
	
  -- FAZ A LEITURA DOS SEGMENTOS DA TABELA NA TABLESPACE
  FOR R13 IN C_SEGMENTS_TS LOOP

  -- TABELA  
    FOR R1 IN C_TABLES(R13.SEGMENT_OWNER, R13.SEGMENT_NAME, R13.PARTITION_NAME) LOOP
    
      -- VALIDA SE É PARTICIONADA
      IF R1.PARTITIONED = 'YES' THEN
  	
      -- PEGA A DATA DA PARTICAO
      BEGIN
        SELECT HIGH_VALUE 
        INTO V_INCOMING 
        FROM DBA_TAB_PARTITIONS
        WHERE TABLE_OWNER = R1.TABLE_OWNER
          AND TABLE_NAME = R1.TABLE_NAME
          AND PARTITION_NAME = R1.PARTITION_NAME;
          
        V_DAT_PART := SUBSTR(V_INCOMING,11,11);          
          
        EXCEPTION
          WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('--------------------------------');
            DBMS_OUTPUT.PUT_LINE('[ERRO]: ' || TO_CHAR(SQLERRM) || CHR(10) || TO_CHAR(DBMS_UTILITY.FORMAT_ERROR_BACKTRACE));
            DBMS_OUTPUT.PUT_LINE('[TABELA]: ' || R1.TABLE_NAME || CHR(10) || '[PARTICAO]: '|| R1.PARTITION_NAME || CHR(10) ||'[DATA]: '||V_DAT_PART);
            DBMS_OUTPUT.PUT_LINE('--------------------------------');    
          
          WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('--------------------------------');			
            DBMS_OUTPUT.PUT_LINE('[ERRO]: ' || TO_CHAR(SQLERRM) || CHR(10) || TO_CHAR(DBMS_UTILITY.FORMAT_ERROR_BACKTRACE));
            DBMS_OUTPUT.PUT_LINE('--------------------------------');    
      END;    
f  	  
  	  -- VALIDA SE A DATA DE PARTICAO ESTÁ DENTRO DA DATA DE CORTE, SE ESTIVER, A PARTICAO TERA COMPRESSAO
        IF TO_DATE(V_DAT_PART,'YYYY-MM-DD') < P_DAT_CORTE_COMPRESS THEN	  
  	    
          V_MOVE_TAB := '-- '||R1.TABLE_NAME||' -- '||R1.PARTITION_NAME||' -- '||V_DAT_PART||' -- '||R1.SIZE_GB||' GB '||CHR(10)||'ALTER TABLE '|| R1.TABLE_OWNER||'.'||R1.TABLE_NAME||' MOVE PARTITION '||R1.PARTITION_NAME||' TABLESPACE '||NVL(P_TSDDEST,R1.TABLESPACE_NAME)||V_PARAM_COMPRESS||V_PARAM_UPDATE_INDEX||V_PARAMS;
   	    
  	    ELSE
  	  
          V_MOVE_TAB := '-- '||R1.TABLE_NAME||' -- '||R1.PARTITION_NAME||' -- '||V_DAT_PART||' -- '||R1.SIZE_GB||' GB '||CHR(10)||'ALTER TABLE '|| R1.TABLE_OWNER||'.'||R1.TABLE_NAME||' MOVE PARTITION '||R1.PARTITION_NAME||' TABLESPACE '||NVL(P_TSDDEST,R1.TABLESPACE_NAME)||V_PARAM_UPDATE_INDEX||V_PARAMS;	    
  	
        END IF;	
  	  
        DBMS_OUTPUT.PUT_LINE(V_MOVE_TAB);	
        
  	    -- MOVE OS CAMPOS LOB	  
  	    IF P_MOVE_LOB = 'S' THEN
  	    
  		  FOR R2 IN C_LOBS(R1.TABLE_OWNER, R1.TABLE_NAME, R1.PARTITION_NAME) LOOP
  	    
            V_MOVE_LOB := '-- '||R1.PARTITION_NAME||' -- '||R2.SIZE_GB||' GB '||CHR(10)||'ALTER TABLE '|| R2.LOB_OWNER||'.'||R2.TABLE_NAME||' MOVE PARTITION '||R1.PARTITION_NAME||' LOB('||R2.LOB_NAME||') STORE AS (TABLESPACE '||NVL(P_TSLDEST,R2.TABLESPACE_NAME)||')'||V_PARAM_COMPRESS||V_PARAM_UPDATE_INDEX||V_PARAMS;
          
  		    DBMS_OUTPUT.PUT_LINE(V_MOVE_LOB);	
  	    
  	      END LOOP;
  	  
        END IF;
  
        -- MOVE INDICES
  	    IF P_MOVE_INDEX = 'S' THEN
  	  
          IF P_UPDATE_INDEX = 'N' THEN
  	    
            FOR R3 IN C_INDEXES(R1.TABLE_OWNER, R1.TABLE_NAME, R1.PARTITION_NAME) LOOP
  	        
    	      -- VALIDA SE A DATA DE PARTICAO ESTÁ DENTRO DA DATA DE CORTE, SE ESTIVER, O INDICE TERA COMPRESSAO
              IF TO_DATE(V_DAT_PART,'YYYY-MM-DD') < P_DAT_CORTE_COMPRESS THEN	  
			
                V_MOVE_IND := '-- '||R3.INDEX_NAME||' -- '||R3.PARTITION_NAME||' -- '||R3.SIZE_GB||' GB '||CHR(10)||'ALTER INDEX '||R3.INDEX_OWNER||'.'||R3.INDEX_NAME||' REBUILD PARTITION '||R3.PARTITION_NAME||' COMPRESS ADVANCED TABLESPACE '||NVL(P_TSIDEST,R3.TABLESPACE_NAME)||V_PARAMS;
 	    
	          ELSE
	  
                V_MOVE_IND := '-- '||R3.INDEX_NAME||' -- '||R3.PARTITION_NAME||' -- '||R3.SIZE_GB||' GB '||CHR(10)||'ALTER INDEX '||R3.INDEX_OWNER||'.'||R3.INDEX_NAME||' REBUILD PARTITION '||R3.PARTITION_NAME||' TABLESPACE '||NVL(P_TSIDEST,R3.TABLESPACE_NAME)||V_PARAMS;
	
              END IF;	
            
  		      DBMS_OUTPUT.PUT_LINE(V_MOVE_IND);	
  	      
  	        END LOOP;
  	    
  	      END IF; 
  		
        END IF; 	 
  
  	    DBMS_OUTPUT.PUT_LINE('');		  
  	  
  
  	  ELSE -- TABELAS NAO PARTICIONADAS
  	
  	    V_MOVE_TAB := '-- '||R1.TABLE_NAME||' -- '||R1.SIZE_GB||' GB '||CHR(10)||'ALTER TABLE '|| R1.TABLE_OWNER||'.'||R1.TABLE_NAME||' MOVE TABLESPACE '||NVL(P_TSDDEST,R1.TABLESPACE_NAME)||V_PARAM_UPDATE_INDEX||V_PARAMS;
	   
  	    DBMS_OUTPUT.PUT_LINE(V_MOVE_TAB);	
        
        DBMS_OUTPUT.PUT_LINE('');	        
  
  	    -- MOVE OS CAMPOS LOB	  
  	    IF P_MOVE_LOB = 'S' THEN
  	    
  		  FOR R10 IN C_LOBS(R1.TABLE_OWNER, R1.TABLE_NAME, R1.PARTITION_NAME) LOOP
  	    
            V_MOVE_LOB := '-- '||R10.TABLE_NAME||' -- '||R10.SIZE_GB||' GB '||CHR(10)||'ALTER TABLE '|| R10.LOB_OWNER||'.'||R10.TABLE_NAME||' MOVE LOB('||R10.LOB_NAME||') STORE AS (TABLESPACE '||NVL(P_TSLDEST,R10.TABLESPACE_NAME)||')'||V_PARAM_COMPRESS||V_PARAM_UPDATE_INDEX||V_PARAMS;
          
  		    DBMS_OUTPUT.PUT_LINE(V_MOVE_LOB);	
  	    
  	      END LOOP;
  	  
        END IF;
  	
  	  END IF;
    
    END LOOP; -- TABELAS
  
  END LOOP; -- SEGMENTOS
  

  -- RECONSTROI OS INDICES GLOBAIS
  IF P_UPDATE_INDEX = 'N' THEN
  
    FOR R7 IN C_DEF_TS_NO_PART LOOP
    
      IF R7.OBJECT_TYPE = 'INDEX' THEN
      
        V_REBUILD_IND := '-- '||R7.NAME_OBJECT||' -- '||R7.SIZE_GB||' GB '||CHR(10)||'ALTER INDEX '||R7.OWNER_OBJECT||'.'||R7.NAME_OBJECT||' REBUILD TABLESPACE '||NVL(P_TSIDEST,R7.TABLESPACE_NAME)||V_PARAMS;
    
        DBMS_OUTPUT.PUT_LINE(V_REBUILD_IND);		 
        
      END IF;  
      
    END LOOP;
  
  END IF;

  DBMS_OUTPUT.PUT_LINE('');	
	
  -- RETIRA PARALELISMO
  IF P_PARALLEL > 0 THEN
  
    FOR R8 IN C_DEF_TS_PART LOOP
  
      IF R8.OBJECT_TYPE = 'TABLE' THEN
	  
        V_DEF_TSD := 'ALTER TABLE '||R8.OWNER_OBJECT||'.'||R8.NAME_OBJECT||' NOPARALLEL;';
        DBMS_OUTPUT.PUT_LINE(V_DEF_TSD);	
	  
      ELSIF R8.OBJECT_TYPE = 'INDEX' THEN
	  
        V_DEF_TSI := 'ALTER INDEX '||R8.OWNER_OBJECT||'.'||R8.NAME_OBJECT||' NOPARALLEL;';
        DBMS_OUTPUT.PUT_LINE(V_DEF_TSI);	
	  
	  END IF;

    END LOOP;
 
    FOR R9 IN C_DEF_TS_NO_PART LOOP
  
      IF R9.OBJECT_TYPE = 'TABLE' THEN
	  
        V_DEF_TSD := 'ALTER TABLE '||R9.OWNER_OBJECT||'.'||R9.NAME_OBJECT||' NOPARALLEL;';
        DBMS_OUTPUT.PUT_LINE(V_DEF_TSD);	
	  
      ELSIF R9.OBJECT_TYPE = 'INDEX' THEN
	  
        V_DEF_TSI := 'ALTER INDEX '||R9.OWNER_OBJECT||'.'||R9.NAME_OBJECT||' NOPARALLEL;';
        DBMS_OUTPUT.PUT_LINE(V_DEF_TSI);	
	  
	  END IF;

    END LOOP;

  END IF;
  
  DBMS_OUTPUT.PUT_LINE('');  
  
  -- ATIVA FKS DEPOIS DE TUDO EXECUTADO
  IF P_DISABLE_FK = 'S' THEN
  
    FOR R6 IN C_FK LOOP
	
	  V_ENABLE_FK := 'ALTER TABLE '||R6.CONSTRAINT_OWNER||'.'||R6.TABLE_NAME||' ADD CONSTRAINT ' || R6.CONSTRAINT_NAME||' FOREIGN KEY ('||R6.COLUMNS_NAME||') REFERENCES '||R6.OWNER_R||'.'||R6.TABLE_NAME_R||'('||R6.COLUMNS_NAME||') ENABLE NOVALIDATE;';

	  DBMS_OUTPUT.PUT_LINE(V_ENABLE_FK);	
	  
	END LOOP;
  
  END IF;

  DBMS_OUTPUT.PUT_LINE('');  
  
  -- COLETA ESTATISTICAS
  IF P_COLLECT_STATS = 'S' THEN
  
    FOR R14 IN C_SEGMENTS_TS LOOP
  
      FOR R11 IN C_TABLES(R14.SEGMENT_OWNER, R14.SEGMENT_NAME, R14.PARTITION_NAME) LOOP
  	
  	    IF R11.PARTITIONED = 'YES' THEN
  	  
  	      V_COLLECT_TAB := 'EXEC DBMS_STATS.GATHER_TABLE_STATS( OWNNAME=>'''|| R11.TABLE_OWNER||''', TABNAME=>'''||R11.TABLE_NAME||''', PARTNAME=>'''||R11.PARTITION_NAME||''', ESTIMATE_PERCENT => dbms_stats.auto_sample_size, DEGREE => '||TO_CHAR(P_PARALLEL)||', GRANULARITY => ''AUTO'', NO_INVALIDATE => TRUE ); ';
  	  
  	    ELSE
  	  
  	      V_COLLECT_TAB := 'EXEC DBMS_STATS.GATHER_TABLE_STATS( OWNNAME=>'''|| R11.TABLE_OWNER||''', TABNAME=>'''||R11.TABLE_NAME||''', ESTIMATE_PERCENT => dbms_stats.auto_sample_size, DEGREE => '||TO_CHAR(P_PARALLEL)||', GRANULARITY => ''AUTO'', NO_INVALIDATE => TRUE ); ';
  		
  	    END IF;
  	
        DBMS_OUTPUT.PUT_LINE(V_COLLECT_TAB);	
  	  
        FOR R12 IN C_INDEXES(R11.TABLE_OWNER, R11.TABLE_NAME, R11.PARTITION_NAME) LOOP
  	
     	  IF R12.PARTITIONED = 'YES' THEN
     	    
     	    V_COLLECT_IND := 'EXEC DBMS_STATS.GATHER_INDEX_STATS( OWNNAME=>'''|| R12.INDEX_OWNER||''', INDNAME=>'''||R12.INDEX_NAME||''', PARTNAME=>'''||R12.PARTITION_NAME||''', ESTIMATE_PERCENT => dbms_stats.auto_sample_size, DEGREE => '||TO_CHAR(P_PARALLEL)||', GRANULARITY => ''AUTO'', NO_INVALIDATE => TRUE ); ';
     	    	   
     	  ELSE
     	    
     	    V_COLLECT_IND := 'EXEC DBMS_STATS.GATHER_INDEX_STATS( OWNNAME=>'''|| R12.INDEX_OWNER||''', INDNAME=>'''||R12.INDEX_NAME||''', ESTIMATE_PERCENT => dbms_stats.auto_sample_size, DEGREE => '||TO_CHAR(P_PARALLEL)||', GRANULARITY => ''AUTO'', NO_INVALIDATE => TRUE ); ';
     		  
     	  END IF;
  	    
     	  DBMS_OUTPUT.PUT_LINE(V_COLLECT_IND);	
     	
     	END LOOP;
		
	  END LOOP;
	
  	END LOOP;  
	
   	DBMS_OUTPUT.PUT_LINE('');	
		  
    FOR R15 IN C_DEF_TS_NO_PART LOOP
  
      IF R15.OBJECT_TYPE = 'INDEX' THEN
	  
  	    V_COLLECT_IND := 'EXEC DBMS_STATS.GATHER_INDEX_STATS( OWNNAME=>'''|| R15.OWNER_OBJECT||''', INDNAME=>'''||R15.NAME_OBJECT||''', ESTIMATE_PERCENT => dbms_stats.auto_sample_size, DEGREE => '||TO_CHAR(P_PARALLEL)||', GRANULARITY => ''AUTO'', NO_INVALIDATE => TRUE ); ';      
    	DBMS_OUTPUT.PUT_LINE(V_COLLECT_IND);	
	  
	  END IF;

    END LOOP;
  
  END IF;  

END;
/
SHOW ERRORS