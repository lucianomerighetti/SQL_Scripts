/*
AUTOMATIZACAO DE SCRIPT DE EXPURGO -- EXCLUIRA TODOS OS SEGMENTOS DE UMA TABELA A PARTIR DE RANGE
*/

SET SERVEROUTPUT ON SIZE UNLIMITED
EXEC DBMS_OUTPUT.ENABLE (buffer_size => NULL);
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';

DECLARE

  P_TABLE VARCHAR2(4000) := 'CCE_CHANGE_EVENT_SCHEDULE'; -- NOME DA TABELA DA OPERACAO
  P_TSIDEST VARCHAR2(4000) := 'TSIRECEIVABLES04'; -- TABLESPACE DE INDICE DESTINO  
  P_PARALLEL  NUMBER(2) := 6; -- VALOR DO PARALELISMO
  P_ONLINE  CHAR(1) := 'S'; -- SE FOR UMA ATIVIDADE ONLINE, COLOQUE 'S', SE NAO,'N'
  P_UPDATE_INDEX CHAR(1) := 'S'; -- SE TIVER UPDATE INDEX COLOQUE 'S', SE NAO,'N' 
  P_DISABLE_FK CHAR(1) := 'S'; -- OPCAO DE DESATIVAR FKS
  P_COLLECT_STATS CHAR(1) := 'N'; -- OPCAO DE COLETAR ESTATISTICAS APOS OS MOVES
  P_QTDE_DIAS_RETENCAO NUMBER(4)  := 12; -- QUANTIDADE DE DIAS DE RETENCAO DE DADOS
  
  
  V_OWNER VARCHAR2(100) := SUBSTR(SYS_CONTEXT('USERENV','DB_NAME'),4,50)||'_ADM';  
  V_INCOMING VARCHAR2(32767);
  V_DAT_PART DATE;
  V_DROP_PART VARCHAR2(4000);
  V_REBUILD_IND VARCHAR2(4000);
  V_COLLECT_TAB VARCHAR2(4000);
  V_COLLECT_IND VARCHAR2(4000);
  V_DEF_TSD VARCHAR(4000);
  V_DEF_TSI VARCHAR(4000);
  V_DEF_TSL VARCHAR(4000);  
  V_DISABLE_FK VARCHAR(4000);  
  V_ENABLE_FK VARCHAR(4000);    
  V_PARALLEL VARCHAR(4000);
  V_PARAMS VARCHAR(4000);  
  V_PARAM_UPDATE_INDEX VARCHAR2(4000);
  V_DAT_LIMIT_DROP DATE;  

-- Busca dados básicos da tabela
CURSOR C_TABLES IS
  SELECT T.OWNER  AS TABLE_OWNER	
  	    ,T.TABLE_NAME
  	    ,NVL(S.PARTITION_NAME,'NP') AS PARTITION_NAME
        ,NVL(T.TABLESPACE_NAME,S.TABLESPACE_NAME) AS TABLESPACE_NAME
        ,T.PARTITIONED		
        ,ROUND(NVL(S.BYTES,0)/1024/1024,2) SIZE_MB		
        ,ROUND(NVL(S.BYTES,0)/1024/1024/1024,2) SIZE_GB		
        ,ROUND(NVL(S.BYTES,0)/1024/1024/1024/1024,2) SIZE_TB	
  FROM DBA_TABLES T
  LEFT JOIN DBA_SEGMENTS S		
  ON S.OWNER = T.OWNER 		
  AND S.SEGMENT_NAME = T.TABLE_NAME		
  WHERE T.OWNER = V_OWNER
  AND T.TABLE_NAME = P_TABLE
  ORDER BY 5, 7;  

-- Busca dados padrao dos objetos particionados da tabela
CURSOR C_DEF_TS_PART IS
  SELECT PT.OWNER OWNER_OBJECT
        ,PT.TABLE_NAME NAME_RELATED
        ,PT.TABLE_NAME NAME_OBJECT
        ,PT.DEF_TABLESPACE_NAME
        ,O.OBJECT_TYPE
  FROM DBA_PART_TABLES PT
  INNER JOIN DBA_OBJECTS O
  ON PT.OWNER = O.OWNER
  AND PT.TABLE_NAME = O.OBJECT_NAME
  WHERE PT.OWNER = V_OWNER
  AND PT.TABLE_NAME = P_TABLE
  AND O.OBJECT_TYPE = 'TABLE'
  UNION
  SELECT PI.OWNER
        ,PI.TABLE_NAME
        ,PI.INDEX_NAME
        ,PI.DEF_TABLESPACE_NAME
        ,O.OBJECT_TYPE
  FROM DBA_PART_INDEXES PI
  INNER JOIN DBA_OBJECTS O
  ON PI.OWNER = O.OWNER
  AND PI.INDEX_NAME = O.OBJECT_NAME
  LEFT JOIN DBA_PART_LOBS PL
  ON PL.TABLE_OWNER = O.OWNER
  AND PL.LOB_INDEX_NAME = O.OBJECT_NAME
  WHERE PI.OWNER = V_OWNER
  AND PI.TABLE_NAME = P_TABLE
  AND O.OBJECT_TYPE = 'INDEX'
  AND PL.LOB_INDEX_NAME IS NULL
  UNION
  SELECT DISTINCT PL.TABLE_OWNER
                 ,PL.TABLE_NAME
                 ,PL.COLUMN_NAME
                 ,PL.DEF_TABLESPACE_NAME
                 ,'LOB'
  FROM DBA_PART_LOBS PL
  INNER JOIN DBA_OBJECTS O
  ON PL.TABLE_OWNER = O.OWNER
  AND PL.TABLE_NAME = O.OBJECT_NAME
  WHERE PL.TABLE_OWNER = V_OWNER
  AND PL.TABLE_NAME = P_TABLE
  AND O.OBJECT_TYPE = 'TABLE';

-- Busca dados padrao dos objetos nao particionados da tabela
CURSOR C_DEF_TS_NO_PART IS
  SELECT T.OWNER OWNER_OBJECT
        ,T.TABLE_NAME NAME_RELATED
        ,T.TABLE_NAME NAME_OBJECT
        ,T.TABLESPACE_NAME
        ,O.OBJECT_TYPE
        ,ROUND(NVL(S.BYTES,0)/1024/1024,2) SIZE_MB		
        ,ROUND(NVL(S.BYTES,0)/1024/1024/1024,2) SIZE_GB		
        ,ROUND(NVL(S.BYTES,0)/1024/1024/1024/1024,2) SIZE_TB	        
  FROM DBA_TABLES T
  INNER JOIN DBA_OBJECTS O
  ON T.OWNER = O.OWNER
  AND T.TABLE_NAME = O.OBJECT_NAME
  INNER JOIN DBA_SEGMENTS S
  ON T.OWNER = S.OWNER
  AND T.TABLE_NAME = S.SEGMENT_NAME  
  WHERE T.OWNER = V_OWNER
  AND T.TABLE_NAME = P_TABLE
  AND O.OBJECT_TYPE = 'TABLE'
  AND T.PARTITIONED = 'NO'
  UNION  
  SELECT I.OWNER
        ,I.TABLE_NAME
        ,I.INDEX_NAME
        ,I.TABLESPACE_NAME
        ,O.OBJECT_TYPE
        ,ROUND(NVL(S.BYTES,0)/1024/1024,2) SIZE_MB		
        ,ROUND(NVL(S.BYTES,0)/1024/1024/1024,2) SIZE_GB		
        ,ROUND(NVL(S.BYTES,0)/1024/1024/1024/1024,2) SIZE_TB	        
  FROM DBA_INDEXES I
  INNER JOIN DBA_OBJECTS O
  ON I.OWNER = O.OWNER
  AND I.INDEX_NAME = O.OBJECT_NAME
  INNER JOIN DBA_SEGMENTS S
  ON I.OWNER = S.OWNER
  AND I.INDEX_NAME = S.SEGMENT_NAME    
  WHERE I.OWNER = V_OWNER
  AND I.TABLE_NAME = P_TABLE
  AND O.OBJECT_TYPE = 'INDEX'
  AND I.PARTITIONED = 'NO'    
  UNION
  SELECT DISTINCT L.OWNER
                 ,L.TABLE_NAME
                 ,L.COLUMN_NAME
                 ,L.TABLESPACE_NAME
                 ,'LOB'
                 ,ROUND(NVL(S.BYTES,0)/1024/1024,2) SIZE_MB		
                 ,ROUND(NVL(S.BYTES,0)/1024/1024/1024,2) SIZE_GB		
                 ,ROUND(NVL(S.BYTES,0)/1024/1024/1024/1024,2) SIZE_TB	        
  FROM DBA_LOBS L
  INNER JOIN DBA_OBJECTS O
  ON L.OWNER = O.OWNER
  AND L.TABLE_NAME = O.OBJECT_NAME
  INNER JOIN DBA_SEGMENTS S
  ON L.OWNER = S.OWNER
  AND L.TABLE_NAME = S.SEGMENT_NAME      
  WHERE L.OWNER = V_OWNER
  AND L.TABLE_NAME = P_TABLE
  AND O.OBJECT_TYPE = 'TABLE'
  AND L.PARTITIONED = 'NO';

-- Busca dados das constraints de relacionamento
CURSOR C_FK IS
  SELECT C.OWNER CONSTRAINT_OWNER
         ,C.TABLE_NAME
         ,C.CONSTRAINT_NAME
         ,LISTAGG(CC.COLUMN_NAME,', ') COLUMNS_NAME
         ,CR.OWNER OWNER_R
         ,CR.TABLE_NAME TABLE_NAME_R
  FROM DBA_CONSTRAINTS C 
  INNER JOIN DBA_CONS_COLUMNS CC
  ON C.OWNER = CC.OWNER
  AND C.TABLE_NAME = CC.TABLE_NAME
  AND C.CONSTRAINT_NAME = CC.CONSTRAINT_NAME
  INNER JOIN DBA_CONSTRAINTS CR
  ON CR.OWNER = C.R_OWNER
  AND CR.CONSTRAINT_NAME = C.R_CONSTRAINT_NAME 
  WHERE C.OWNER = V_OWNER
  AND (C.TABLE_NAME = P_TABLE OR CR.TABLE_NAME = P_TABLE)
  AND C.CONSTRAINT_TYPE = 'R'
  GROUP BY C.OWNER
        ,C.TABLE_NAME
        ,C.CONSTRAINT_NAME
        ,CR.OWNER
        ,CR.TABLE_NAME; 
        
CURSOR C_TABLE_DATA IS
  SELECT T.OWNER
        ,T.TABLE_NAME
        ,T.PARTITIONED
        ,CASE WHEN ROUND(SUM(S.BYTES)/1024/1024/1024/1024,2) <= 0 THEN 
              TO_CHAR(ROUND(SUM(S.BYTES)/1024/1024/1024,2))||' GB' 
         ELSE TO_CHAR(ROUND(SUM(S.BYTES)/1024/1024/1024/1024,2))||' TB' 
  END SUM_BYTES
        ,IG.QTY_INDEXES_GLOBAL
        ,IG.SUM_BYTES_INDEXES_GLOBAL
  FROM DBA_TABLES T
  INNER JOIN DBA_SEGMENTS S
  ON T.OWNER = S.OWNER
  AND T.TABLE_NAME = S.SEGMENT_NAME
  LEFT JOIN (
  SELECT I.TABLE_NAME
        ,COUNT(1) QTY_INDEXES_GLOBAL
        ,CASE WHEN ROUND(SUM(S.BYTES)/1024/1024/1024/1024,2) <= 0 THEN 
                   TO_CHAR(ROUND(SUM(S.BYTES)/1024/1024/1024,2))||' GB' 
              ELSE TO_CHAR(ROUND(SUM(S.BYTES)/1024/1024/1024/1024,2))||' TB' 
         END SUM_BYTES_INDEXES_GLOBAL      
        ,COUNT(*) QTY_PART
        ,ROUND(SUM(S.BYTES)/1024/1024/1024,2) TAM_GB
        ,ROUND(SUM(S.BYTES)/1024/1024/1024/1024,2) TAM_TB
  FROM DBA_SEGMENTS S
  INNER JOIN DBA_INDEXES I
  ON S.OWNER = I.OWNER
  AND S.SEGMENT_NAME = I.INDEX_NAME
  WHERE S.OWNER = V_OWNER
  AND S.SEGMENT_TYPE = 'INDEX'
  AND I.PARTITIONED = 'NO'
  GROUP BY I.TABLE_NAME) IG
  ON S.SEGMENT_NAME = IG.TABLE_NAME
  WHERE T.OWNER = V_OWNER
  AND T.TABLE_NAME = P_TABLE
  GROUP BY T.OWNER
          ,T.TABLE_NAME
          ,T.PARTITIONED
          ,IG.QTY_INDEXES_GLOBAL
          ,IG.SUM_BYTES_INDEXES_GLOBAL;



BEGIN 
  
  V_INCOMING := '';
  V_DAT_PART := '';
  V_DROP_PART := '';
  V_REBUILD_IND := '';
  V_COLLECT_TAB := '';
  V_COLLECT_IND := '';
  V_DEF_TSD := '';
  V_DEF_TSI := '';
  V_DEF_TSL := '';
  V_DISABLE_FK := '';
  V_ENABLE_FK := '';
  V_PARALLEL := '';
  V_PARAMS := '';  
  V_PARAM_UPDATE_INDEX := '';
  V_DAT_LIMIT_DROP := '';
  
  IF P_PARALLEL IS NOT NULL THEN
    V_PARALLEL := V_PARALLEL||' PARALLEL '||TO_CHAR(P_PARALLEL);  
  END IF;  
  
  IF P_ONLINE = 'S' THEN
    V_PARAMS := V_PARAMS||' ONLINE';
  END IF;
  
  V_PARAMS := V_PARAMS||';'; 
  
  IF P_UPDATE_INDEX = 'S' THEN
    V_PARAM_UPDATE_INDEX := ' UPDATE INDEXES'||V_PARALLEL;
  END IF;
  
  IF P_QTDE_DIAS_RETENCAO > 0 THEN
    V_DAT_LIMIT_DROP := TRUNC(SYSDATE) - P_QTDE_DIAS_RETENCAO;
  END IF;
  
  
  DBMS_OUTPUT.PUT_LINE('/*');
  DBMS_OUTPUT.PUT_LINE('********************************************************************************************** ');
  DBMS_OUTPUT.PUT_LINE('BANCO: '||SYS_CONTEXT('USERENV','DB_NAME'));
  DBMS_OUTPUT.PUT_LINE('HOST: '||SYS_CONTEXT('USERENV','DB_NAME')||'.BD.INTRANET.PAGS:1521/'||SYS_CONTEXT('USERENV','DB_NAME'));  
  DBMS_OUTPUT.PUT_LINE('********************************************************************************************** ');
  DBMS_OUTPUT.PUT_LINE('*/');
  DBMS_OUTPUT.PUT_LINE(' ');
  DBMS_OUTPUT.PUT_LINE(' ');
  DBMS_OUTPUT.PUT_LINE(' ');
  DBMS_OUTPUT.PUT_LINE('-- Mostra o tempo de execução de cada comando');  
  DBMS_OUTPUT.PUT_LINE('SET TIMING ON');	 
  DBMS_OUTPUT.PUT_LINE('-- Conecta no container e service correto. Se forem os bancos PDBRECEIVABLES e PDBSETTLEMENTCONTRACT');  
  DBMS_OUTPUT.PUT_LINE('-- os services names corretos são, respectivamente RECEIVABLES e SETTLEMENTCONTRACT');    
  DBMS_OUTPUT.PUT_LINE('ALTER SESSION SET CONTAINER = '||SYS_CONTEXT('USERENV','DB_NAME')||' SERVICE = '||SYS_CONTEXT('USERENV','DB_NAME')||';');	  
  DBMS_OUTPUT.PUT_LINE('-- Força a sessão a executar os comandos DDL com paralelismo');  
  DBMS_OUTPUT.PUT_LINE('ALTER SESSION ENABLE PARALLEL DDL;');	  
  DBMS_OUTPUT.PUT_LINE('-- Se for RFC com a app ligada, usar o comando abaixo, se for com parada de aplicação, pode retirar');
  DBMS_OUTPUT.PUT_LINE('ALTER SESSION SET DDL_LOCK_TIMEOUT = 30;');	    
  DBMS_OUTPUT.PUT_LINE('-- Especifica o grau de paralelismo usado ao recuperar transações encerradas, caso tenha rollback/recovery');	    
  DBMS_OUTPUT.PUT_LINE('ALTER SYSTEM SET FAST_START_PARALLEL_ROLLBACK = HIGH;');	      
  DBMS_OUTPUT.PUT_LINE(' ');
  DBMS_OUTPUT.PUT_LINE(' ');
  DBMS_OUTPUT.PUT_LINE('-- OBSERVAÇÃO: Caso tenha sessões de usuários nominais ativas, forçar o kill session e se retornar, bloquear o usuário');	        
  DBMS_OUTPUT.PUT_LINE(' ');
  DBMS_OUTPUT.PUT_LINE(' ');
  DBMS_OUTPUT.PUT_LINE(' ');
  DBMS_OUTPUT.PUT_LINE('/*');
  DBMS_OUTPUT.PUT_LINE('********************************************************************************************** ');
  DBMS_OUTPUT.PUT_LINE('TABELA: '||P_TABLE);

  -- DADOS DA TABELA
  
  FOR R16 IN C_TABLE_DATA LOOP
    DBMS_OUTPUT.PUT_LINE('PARTICIONADA: '||R16.PARTITIONED);    
    DBMS_OUTPUT.PUT_LINE('TAMANHO: '||R16.SUM_BYTES);        
    DBMS_OUTPUT.PUT_LINE('QUANTIDADE INDICES GLOBAIS: '||R16.QTY_INDEXES_GLOBAL);     
    DBMS_OUTPUT.PUT_LINE('TAMANHO TOTAL INDICES GLOBAIS: '||R16.SUM_BYTES_INDEXES_GLOBAL);  
    DBMS_OUTPUT.PUT_LINE('********************************************************************************************** ');
    DBMS_OUTPUT.PUT_LINE('*/');
    DBMS_OUTPUT.PUT_LINE(' ');
    DBMS_OUTPUT.PUT_LINE(' ');
    DBMS_OUTPUT.PUT_LINE(' ');
  END LOOP;


  -- DESATIVA FKS
  IF P_DISABLE_FK = 'S' THEN
  
    FOR R5 IN C_FK LOOP
	
	  V_DISABLE_FK := 'ALTER TABLE '||R5.CONSTRAINT_OWNER||'.'||R5.TABLE_NAME||' DROP CONSTRAINT ' || R5.CONSTRAINT_NAME||';';

	  DBMS_OUTPUT.PUT_LINE(V_DISABLE_FK);	
	  
	END LOOP;
  
  END IF;  

  DBMS_OUTPUT.PUT_LINE('');
  
-- TABELA  
  FOR R1 IN C_TABLES LOOP
  
    -- VALIDA SE É PARTICIONADA
    IF R1.PARTITIONED = 'YES' THEN
	
      -- PEGA A DATA DA PARTICAO
      BEGIN
        SELECT HIGH_VALUE 
        INTO V_INCOMING 
        FROM DBA_TAB_PARTITIONS
        WHERE TABLE_OWNER = R1.TABLE_OWNER
          AND TABLE_NAME = R1.TABLE_NAME
          AND PARTITION_NAME = R1.PARTITION_NAME;
          
        V_DAT_PART := SUBSTR(V_INCOMING,11,11);          
          
        EXCEPTION
          WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('--------------------------------');
            DBMS_OUTPUT.PUT_LINE('[ERRO]: ' || TO_CHAR(SQLERRM) || CHR(10) || TO_CHAR(DBMS_UTILITY.FORMAT_ERROR_BACKTRACE));
            DBMS_OUTPUT.PUT_LINE('[TABELA]: ' || R1.TABLE_NAME || CHR(10) || '[PARTICAO]: '|| R1.PARTITION_NAME || CHR(10) ||'[DATA]: '||V_DAT_PART);
            DBMS_OUTPUT.PUT_LINE('--------------------------------');    
          
          WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('--------------------------------');			
            DBMS_OUTPUT.PUT_LINE('[ERRO]: ' || TO_CHAR(SQLERRM) || CHR(10) || TO_CHAR(DBMS_UTILITY.FORMAT_ERROR_BACKTRACE));
            DBMS_OUTPUT.PUT_LINE('--------------------------------');    
      END;    
	  
	  -- VALIDA SE A DATA DE PARTICAO ESTÁ DENTRO DA DATA DE CORTE DO EXPURGO
      IF TO_DATE(V_DAT_PART,'YYYY-MM-DD') < V_DAT_LIMIT_DROP THEN	  
	    
        V_DROP_PART := '-- '||R1.TABLE_NAME||' -- '||R1.PARTITION_NAME||' -- '||V_DAT_PART||' -- '||R1.SIZE_GB||' GB '||CHR(10)||'ALTER TABLE '|| R1.TABLE_OWNER||'.'||R1.TABLE_NAME||' DROP PARTITION '||R1.PARTITION_NAME||V_PARAM_UPDATE_INDEX||V_PARAMS;
 	    
        DBMS_OUTPUT.PUT_LINE(V_DROP_PART);
		
	  ELSE

	    V_DROP_PART := '';

      END IF;	
      
	END IF;
      
  END LOOP; -- TABELAS

  DBMS_OUTPUT.PUT_LINE('');		  
	  
  -- RECONSTROI OS INDICES GLOBAIS
  IF P_UPDATE_INDEX = 'N' THEN
  
    FOR R7 IN C_DEF_TS_NO_PART LOOP
    
      IF R7.OBJECT_TYPE = 'INDEX' THEN
    
        V_REBUILD_IND := '-- '||R7.NAME_OBJECT||' -- '||R7.SIZE_GB||' GB '||CHR(10)||'ALTER INDEX '||R7.OWNER_OBJECT||'.'||R7.NAME_OBJECT||' REBUILD TABLESPACE '||NVL(P_TSIDEST,R7.TABLESPACE_NAME)||V_PARALLEL||V_PARAMS;
    
        DBMS_OUTPUT.PUT_LINE(V_REBUILD_IND);		 
  	  
  	END IF;  
      
    END LOOP;
  
  END IF;

  DBMS_OUTPUT.PUT_LINE('');	
	
  -- RETIRA PARALELISMO
  IF P_PARALLEL > 0 THEN
  
    FOR R8 IN C_DEF_TS_PART LOOP
  
      IF R8.OBJECT_TYPE = 'TABLE' THEN
	  
        V_DEF_TSD := 'ALTER TABLE '||R8.OWNER_OBJECT||'.'||R8.NAME_OBJECT||' NOPARALLEL;';
        DBMS_OUTPUT.PUT_LINE(V_DEF_TSD);	
	  
      ELSIF R8.OBJECT_TYPE = 'INDEX' THEN
	  
        V_DEF_TSI := 'ALTER INDEX '||R8.OWNER_OBJECT||'.'||R8.NAME_OBJECT||' NOPARALLEL;';
        DBMS_OUTPUT.PUT_LINE(V_DEF_TSI);	
	  
	  END IF;

    END LOOP;
 
    FOR R9 IN C_DEF_TS_NO_PART LOOP
  
      IF R9.OBJECT_TYPE = 'TABLE' THEN
	  
        V_DEF_TSD := 'ALTER TABLE '||R9.OWNER_OBJECT||'.'||R9.NAME_OBJECT||' NOPARALLEL;';
        DBMS_OUTPUT.PUT_LINE(V_DEF_TSD);	
	  
      ELSIF R9.OBJECT_TYPE = 'INDEX' THEN
	  
        V_DEF_TSI := 'ALTER INDEX '||R9.OWNER_OBJECT||'.'||R9.NAME_OBJECT||' NOPARALLEL;';
        DBMS_OUTPUT.PUT_LINE(V_DEF_TSI);	
	  
	  END IF;

    END LOOP;

  END IF;
  
  DBMS_OUTPUT.PUT_LINE('');  
  
  -- ATIVA FKS DEPOIS DE TUDO EXECUTADO
  IF P_DISABLE_FK = 'S' THEN
  
    FOR R6 IN C_FK LOOP
	
	  V_ENABLE_FK := 'ALTER TABLE '||R6.CONSTRAINT_OWNER||'.'||R6.TABLE_NAME||' ADD CONSTRAINT ' || R6.CONSTRAINT_NAME||' FOREIGN KEY ('||R6.COLUMNS_NAME||') REFERENCES '||R6.OWNER_R||'.'||R6.TABLE_NAME_R||'('||R6.COLUMNS_NAME||') ENABLE NOVALIDATE;';

	  DBMS_OUTPUT.PUT_LINE(V_ENABLE_FK);	
	  
	END LOOP;
  
  END IF;

  DBMS_OUTPUT.PUT_LINE('');  
  
  -- COLETA ESTATISTICAS
  IF P_COLLECT_STATS = 'S' THEN
  
    FOR R15 IN C_DEF_TS_NO_PART LOOP
  
      IF R15.OBJECT_TYPE = 'INDEX' THEN
	  
        V_COLLECT_IND := 'ALTER INDEX '|| R15.OWNER_OBJECT||'.'||R15.NAME_OBJECT||' COALESCE CLEANUP'||V_PARAMS;      
    	DBMS_OUTPUT.PUT_LINE(V_COLLECT_IND);	
	  
    	DBMS_OUTPUT.PUT_LINE('');	
	  	  
		-- RETIRA PARALELISMO
        IF P_PARALLEL > 0 THEN  
          V_COLLECT_IND := 'ALTER INDEX '|| R15.OWNER_OBJECT||'.'||R15.NAME_OBJECT||' NOPARALLEL;';
    	  DBMS_OUTPUT.PUT_LINE(V_COLLECT_IND);	
		  
    	  DBMS_OUTPUT.PUT_LINE('');	
		END IF;

        V_COLLECT_IND := 'EXEC DBMS_STATS.GATHER_INDEX_STATS( OWNNAME=>'''|| R15.OWNER_OBJECT||''', INDNAME=>'''||R15.NAME_OBJECT||''', ESTIMATE_PERCENT => dbms_stats.auto_sample_size, DEGREE => '||TO_CHAR(P_PARALLEL)||', GRANULARITY => ''AUTO'', NO_INVALIDATE => TRUE ); ';      
    	DBMS_OUTPUT.PUT_LINE(V_COLLECT_IND);	
	  
	  END IF;

    END LOOP;	
	
  END IF;  

END;
/
SHOW ERRORS
