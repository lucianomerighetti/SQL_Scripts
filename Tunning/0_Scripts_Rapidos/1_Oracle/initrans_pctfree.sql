--- https://decipherinfosys.wordpress.com/2008/03/27/calculating-rows-per-block-in-oracle/

--
-- perfil de utilizacao da tabela
--

WITH DATSIZE AS (
  SELECT --+ MATERIALIZE
         T.OWNER, T.TABLE_NAME, S.SEGMENT_TYPE, T.NUM_ROWS, SUM(S.BYTES) AS SIZEB
    FROM DBA_TABLES T
         LEFT JOIN DBA_SEGMENTS S ON T.OWNER = S.OWNER AND T.TABLE_NAME = S.SEGMENT_NAME
   WHERE S.SEGMENT_TYPE IN ('TABLE','TABLE PARTITION','TABLE SUBPARTITION','NESTED TABLE','CLUSTER')
     AND T.OWNER = SUBSTR(SYS_CONTEXT('USERENV','DB_NAME'),4,50)||'_ADM' AND T.TABLE_NAME = 'CONTRACTUAL_EFFECT'
GROUP BY T.OWNER, T.TABLE_NAME, S.SEGMENT_TYPE, T.NUM_ROWS ),
--
     IDXSIZE AS (
  SELECT --+ MATERIALIZE
         D.OWNER, D.TABLE_NAME, SUM(S.BYTES) AS SIZEB
    FROM DATSIZE D
         LEFT JOIN DBA_INDEXES I ON D.OWNER = I.TABLE_OWNER AND D.TABLE_NAME = I.TABLE_NAME
         LEFT JOIN DBA_SEGMENTS S ON I.OWNER = S.OWNER AND I.INDEX_NAME = S.SEGMENT_NAME
   WHERE S.SEGMENT_TYPE LIKE 'INDEX%'
GROUP BY D.OWNER, D.TABLE_NAME ),
--
     LOBSIZE AS (
  SELECT --+ MATERIALIZE
         D.OWNER, D.TABLE_NAME, SUM(S.BYTES) AS SIZEB
    FROM DATSIZE D
         LEFT JOIN DBA_LOBS L ON D.OWNER = L.OWNER AND D.TABLE_NAME = L.TABLE_NAME
         LEFT JOIN DBA_SEGMENTS S ON L.OWNER = S.OWNER AND L.SEGMENT_NAME = S.SEGMENT_NAME
   WHERE S.SEGMENT_TYPE IN ('LOBSEGMENT','LOB PARTITION')
GROUP BY D.OWNER, D.TABLE_NAME ),
--
     LIXSIZE AS (
  SELECT --+ MATERIALIZE
         D.OWNER, D.TABLE_NAME, SUM(S.BYTES) AS SIZEB
    FROM DATSIZE D
         LEFT JOIN DBA_LOBS L ON D.OWNER = L.OWNER AND D.TABLE_NAME = L.TABLE_NAME
         LEFT JOIN DBA_SEGMENTS S ON L.OWNER = S.OWNER AND L.SEGMENT_NAME = S.SEGMENT_NAME
   WHERE S.SEGMENT_TYPE = 'LOBINDEX'
GROUP BY D.OWNER, D.TABLE_NAME ),
--
     TBMODS AS (
  SELECT --+ MATERIALIZE
         T.OWNER, T.TABLE_NAME, TM.TIMESTAMP, TM.INSERTS+TM.UPDATES+TM.DELETES AS MODS_SINCE
       , TM.INSERTS, ROUND(TM.INSERTS/(TM.INSERTS+TM.UPDATES+TM.DELETES)*100) AS IPCT
       , TM.UPDATES, ROUND(TM.UPDATES/(TM.INSERTS+TM.UPDATES+TM.DELETES)*100) AS UPCT
       , TM.DELETES, ROUND(TM.DELETES/(TM.INSERTS+TM.UPDATES+TM.DELETES)*100) AS DPCT
    FROM DATSIZE T
         LEFT JOIN DBA_TAB_MODIFICATIONS TM ON T.OWNER = TM.TABLE_OWNER AND T.TABLE_NAME = TM.TABLE_NAME
   WHERE TM.PARTITION_NAME IS NULL )
--
  SELECT D.OWNER AS TABLE_OWNER, D.TABLE_NAME, D.SEGMENT_TYPE, S.NUM_ROWS, S.SAMPLE_SIZE, TO_CHAR(S.LAST_ANALYZED,'YYYY-MM-DD HH24:MI:SS') AS STATS, S.STALE_STATS AS STALE, M.MODS_SINCE
       , ROUND(M.MODS_SINCE/(24*(M.TIMESTAMP-S.LAST_ANALYZED))) AS HOURLY_MODS
       , ROUND( ( ( M.INSERTS + M.UPDATES + M.DELETES ) / CASE WHEN S.NUM_ROWS IS NULL OR S.NUM_ROWS = 0 THEN 1 ELSE S.NUM_ROWS END )*100 ) AS CHANGE_PCT
       , M.IPCT, M.UPCT, M.DPCT
       , ROUND(NVL(D.SIZEB,0)/POWER(1024,3),3) AS DATGB
       , ROUND(NVL(I.SIZEB,0)/POWER(1024,3),3) AS IDXGB
       , ROUND(NVL(L.SIZEB,0)/POWER(1024,3),3) AS LOBGB
       , ROUND(NVL(X.SIZEB,0)/POWER(1024,3),3) AS LIXGB
       , ROUND((NVL(D.SIZEB,0)+NVL(I.SIZEB,0)+NVL(L.SIZEB,0)+NVL(X.SIZEB,0))/POWER(1024,3),3) AS TOTGB
    FROM DATSIZE D
         LEFT JOIN IDXSIZE I ON D.OWNER = I.OWNER AND D.TABLE_NAME = I.TABLE_NAME
         LEFT JOIN LOBSIZE L ON D.OWNER = L.OWNER AND D.TABLE_NAME = L.TABLE_NAME
         LEFT JOIN LIXSIZE X ON D.OWNER = X.OWNER AND D.TABLE_NAME = X.TABLE_NAME
         LEFT JOIN DBA_TAB_STATISTICS S ON D.OWNER = S.OWNER AND D.TABLE_NAME = S.TABLE_NAME
         LEFT JOIN TBMODS M ON D.OWNER = M.OWNER AND D.TABLE_NAME = M.TABLE_NAME
   WHERE S.OBJECT_TYPE = 'TABLE';


--
-- configuração atual da tabela
--

  SELECT TT.OWNER AS TABLE_OWNER
       , TT.TABLE_NAME
       , ROUND(S.BYTES/POWER(1024,3),3) AS SIZE_GB
       , TS.BLOCK_SIZE AS BLOCK_SIZE
       , ROUND(TS.BLOCK_SIZE / TT.AVG_ROW_LEN,2) ROWS_PER_BLOCK_SIMPLE
       , 23 AS ITL_SIZE
       , 65 AS BLOCK_HEADER_OVERHEAD
       , TT.INI_TRANS AS INI_TRANS
       , TT.PCT_FREE AS PCT_FREE
       , TT.AVG_ROW_LEN AS AVG_ROW_LEN
       , (TT.INI_TRANS*23)+65 AS BLOCK_HEADER_SIZE
       , (TS.BLOCK_SIZE-((TT.INI_TRANS*23)+65))*(TT.PCT_FREE/100) AS FREE_SPACE
       , (TS.BLOCK_SIZE-((TT.INI_TRANS*23)+65))-(TS.BLOCK_SIZE-((TT.INI_TRANS*23)+65))*(TT.PCT_FREE/100) AS AVAIL_FOR_DATA
       , ROUND(((TS.BLOCK_SIZE-((TT.INI_TRANS*23)+65))-((TS.BLOCK_SIZE-((TT.INI_TRANS*23)+65))*(TT.PCT_FREE/100)))/(TT.AVG_ROW_LEN+3),2) AS ROWS_PER_BLOCK_DETAIL
    FROM (  SELECT T.OWNER, T.TABLE_NAME, NVL(T.TABLESPACE_NAME, PT.DEF_TABLESPACE_NAME) as TABLESPACE_NAME, NVL(T.INI_TRANS, PT.DEF_INI_TRANS) as INI_TRANS, NVL(T.PCT_FREE, PT.DEF_PCT_FREE) as PCT_FREE, T.AVG_ROW_LEN
            FROM DBA_TABLES T
            LEFT JOIN DBA_PART_TABLES PT
            ON T.OWNER = PT.OWNER
            AND T.TABLE_NAME = PT.TABLE_NAME ) TT
    JOIN DBA_TABLESPACES TS 
    ON TT.TABLESPACE_NAME = TS.TABLESPACE_NAME
    LEFT JOIN (SELECT ST.OWNER, ST.SEGMENT_NAME, SUM(ST.BYTES) BYTES FROM DBA_SEGMENTS ST GROUP BY ST.OWNER, ST.SEGMENT_NAME) S 
    ON TT.OWNER=S.OWNER 
    AND TT.TABLE_NAME=S.SEGMENT_NAME
    WHERE TT.OWNER = SUBSTR(SYS_CONTEXT('USERENV','DB_NAME'),4,50)||'_ADM' 
    AND TT.TABLE_NAME = 'CONTRACTUAL_EFFECT'
    ;

--
-- nova configuração da tabela
--

/*
BLK_SIZE  := 8192 ;
INI_TRANS := 16 ; -- USAR VALOR MENOR QUE OO CAMPO 'ROWS_PER_BLOCK_DETAIL' DA QUERY ACIMA
PCT_FREE  := 20 ; -- LEVAR EM CONTA A TAXA DE UPDATES DA TABELA. SE FOR ALTO, E VALIDO AUMENTAR (O PADRAO E 10)
*/

  SELECT TT.OWNER AS TABLE_OWNER
       , TT.TABLE_NAME
       , ROUND(S.BYTES/POWER(1024,3),3) AS SIZE_GB
       , NVL(:BLK_SIZE,TS.BLOCK_SIZE) AS BLOCK_SIZE
       , ROUND(NVL(:BLK_SIZE,TS.BLOCK_SIZE) / TT.AVG_ROW_LEN,2) ROWS_PER_BLOCK_SIMPLE       
       , 23 AS ITL_SIZE
       , 65 AS BLOCK_HEADER_OVERHEAD
       , NVL(:INI_TRANS,TT.INI_TRANS) AS INI_TRANS
       , NVL(:PCT_FREE,TT.PCT_FREE) AS PCT_FREE
       , TT.AVG_ROW_LEN AS AVG_ROW_LEN
       , (NVL(:INI_TRANS,TT.INI_TRANS)*23)+65 AS BLOCK_HEADER_SIZE
       , (NVL(:BLK_SIZE,TS.BLOCK_SIZE)-((NVL(:INI_TRANS,TT.INI_TRANS)*23)+65))*NVL(:PCT_FREE,TT.PCT_FREE)/100 AS FREE_SPACE
       , (NVL(:BLK_SIZE,TS.BLOCK_SIZE)-((NVL(:INI_TRANS,TT.INI_TRANS)*23)+65))-((NVL(:BLK_SIZE,TS.BLOCK_SIZE)-((NVL(:INI_TRANS,TT.INI_TRANS)*23)+65))*NVL(:PCT_FREE,TT.PCT_FREE)/100) AS AVAIL_FOR_DATA
       , ROUND(((NVL(:BLK_SIZE,TS.BLOCK_SIZE)-((NVL(:INI_TRANS,TT.INI_TRANS)*23)+65))-((NVL(:BLK_SIZE,TS.BLOCK_SIZE)-((NVL(:INI_TRANS,TT.INI_TRANS)*23)+65))*NVL(:PCT_FREE,TT.PCT_FREE)/100))/(TT.AVG_ROW_LEN+3),2) AS ROWS_PER_BLOCK_DETAIL
    FROM (  SELECT T.OWNER, T.TABLE_NAME, NVL(T.TABLESPACE_NAME, PT.DEF_TABLESPACE_NAME) as TABLESPACE_NAME, NVL(T.INI_TRANS, PT.DEF_INI_TRANS) as INI_TRANS, NVL(T.PCT_FREE, PT.DEF_PCT_FREE) as PCT_FREE, T.AVG_ROW_LEN
            FROM DBA_TABLES T
            LEFT JOIN DBA_PART_TABLES PT
            ON T.OWNER = PT.OWNER
            AND T.TABLE_NAME = PT.TABLE_NAME ) TT
    JOIN DBA_TABLESPACES TS 
    ON TT.TABLESPACE_NAME = TS.TABLESPACE_NAME
    LEFT JOIN (SELECT ST.OWNER, ST.SEGMENT_NAME, SUM(ST.BYTES) BYTES FROM DBA_SEGMENTS ST GROUP BY ST.OWNER, ST.SEGMENT_NAME) S 
    ON TT.OWNER=S.OWNER 
    AND TT.TABLE_NAME=S.SEGMENT_NAME
    WHERE TT.OWNER = SUBSTR(SYS_CONTEXT('USERENV','DB_NAME'),4,50)||'_ADM' 
    AND TT.TABLE_NAME = 'CONTRACTUAL_EFFECT'
    ;

