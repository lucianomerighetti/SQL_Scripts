/*
AUTOMATIZACAO DE SCRIPT DE MOVES -- MOVERA TODOS OS SEGMENTOS DE UMA TABLESPACE PARA OUTRA TABLESPACE
*/

SET SERVEROUTPUT ON SIZE UNLIMITED
EXEC DBMS_OUTPUT.ENABLE (buffer_size => NULL);
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';

DECLARE

  P_TSORIG VARCHAR2(4000) := 'TSDRECEIVABLES15'; -- TABLESPACE DE ORIGEM
  P_TSIORIG VARCHAR2(4000) := 'TSIRECEIVABLES01'; -- TABLESPACE DE INDICE ORIGEM
  P_TSLORIG VARCHAR2(4000) := 'TSLRECEIVABLES01'; -- TABLESPACE DE LOB ORIGEM   
  P_TSDDEST VARCHAR2(4000) := 'TSDRECEIVABLES02'; -- TABLESPACE DE DADOS DESTINO
  P_TSIDEST VARCHAR2(4000) := 'TSIRECEIVABLES02'; -- TABLESPACE DE INDICE DESTINO
  P_TSLDEST VARCHAR2(4000) := 'TSLRECEIVABLES01'; -- TABLESPACE DE LOB DESTINO 
  P_MOVE_INDEX CHAR(1) := 'N'; -- VERIFICA SE HAVERA MOVE DE INDICE  
  P_MOVE_LOB   CHAR(1) := 'N'; -- VERIFICA SE HAVERA MOVE DE LOB    
  P_PARALLEL  NUMBER(2) := 12; -- VALOR DO PARALELISMO
  P_ONLINE  CHAR(1) := 'N'; -- SE FOR UMA ATIVIDADE ONLINE, COLOQUE 'S', SE NAO,'N'
  P_COMPRESS CHAR(1) := 'S'; -- SE TIVER COMPRESSAO COLOQUE 'S', SE NAO,'N' 
  P_UPDATE_INDEX CHAR(1) := 'S'; -- SE TIVER UPDATE INDEX COLOQUE 'S', SE NAO,'N' 
  P_DISABLE_FK CHAR(1) := 'S'; -- OPCAO DE DESATIVAR FKS
  P_COLLECT_STATS CHAR(1) := 'S'; -- OPCAO DE COLETAR ESTATISTICAS APOS OS MOVES
  P_DAT_CORTE_COMPRESS  DATE := '2023-01-01'; -- CASO A COMPRESSAO SEJA SOMENTE DE UM PERIODO DE DADOS
  
  
  V_OWNER VARCHAR2(100) := SUBSTR(SYS_CONTEXT('USERENV','DB_NAME'),4,50)||'_ADM';  
  V_INCOMING    VARCHAR2(32767);
  V_DAT_PART  DATE;
  V_MOVE_TAB VARCHAR2(4000);
  V_MOVE_IND VARCHAR2(4000);
  V_MOVE_LOB VARCHAR2(4000);  
  V_REBUILD_IND VARCHAR2(4000);
  V_COLLECT_TAB VARCHAR2(4000);
  V_COLLECT_IND VARCHAR2(4000);
  V_DEF_TSD VARCHAR(4000);
  V_DEF_TSI VARCHAR(4000);
  V_DEF_TSL VARCHAR(4000);  
  V_DISABLE_FK VARCHAR(4000);  
  V_ENABLE_FK VARCHAR(4000);    
  V_PARAMS VARCHAR(4000);  
  V_PARAM_COMPRESS VARCHAR2(4000);
  V_PARAM_UPDATE_INDEX VARCHAR2(4000);  

-- Busca dados básicos dos objetos na tablespace
CURSOR C_OBJECTS IS
  SELECT S.OWNER  AS SEGMENT_OWNER	
  	    ,S.SEGMENT_NAME
        ,S.SEGMENT_TYPE
        ,S.TABLESPACE_NAME
        ,ROUND(NVL(SUM(S.BYTES),0)/1024/1024,2) SIZE_MB		
        ,ROUND(NVL(SUM(S.BYTES),0)/1024/1024/1024,2) SIZE_GB		
        ,ROUND(NVL(SUM(S.BYTES),0)/1024/1024/1024/1024,2) SIZE_TB	
  FROM DBA_SEGMENTS S		
  WHERE S.TABLESPACE_NAME = P_TSORIG
  GROUP BY S.OWNER
  	      ,S.SEGMENT_NAME
          ,S.SEGMENT_TYPE
          ,S.TABLESPACE_NAME
  ORDER BY 6;  

-- Busca dados básicos da tabela
CURSOR C_TABLES (PR_OWNER VARCHAR, PR_OBJECT_NAME VARCHAR) IS
  SELECT T.OWNER  AS TABLE_OWNER	
  	    ,T.TABLE_NAME
  	    ,NVL(S.PARTITION_NAME,'NP') AS PARTITION_NAME
        ,NVL(T.TABLESPACE_NAME,S.TABLESPACE_NAME) AS TABLESPACE_NAME
        ,T.PARTITIONED		
        ,ROUND(NVL(S.BYTES,0)/1024/1024,2) SIZE_MB		
        ,ROUND(NVL(S.BYTES,0)/1024/1024/1024,2) SIZE_GB		
        ,ROUND(NVL(S.BYTES,0)/1024/1024/1024/1024,2) SIZE_TB	
  FROM DBA_TABLES T
  LEFT JOIN DBA_SEGMENTS S		
  ON S.OWNER = T.OWNER 		
  AND S.SEGMENT_NAME = T.TABLE_NAME		
  WHERE T.OWNER = PR_OWNER
  AND T.TABLE_NAME = PR_OBJECT_NAME
  AND NVL(T.TABLESPACE_NAME,S.TABLESPACE_NAME) = P_TSORIG
  ORDER BY 5, 7;
  
-- Busca dados básicos de indices
CURSOR C_INDEXES (PR_OWNER VARCHAR, PR_OBJECT_NAME VARCHAR, PR_PARTITION_NAME VARCHAR) IS
  SELECT I.OWNER AS INDEX_OWNER
        ,I.INDEX_NAME
        ,I.TABLE_OWNER
  	    ,I.TABLE_NAME
  	    ,NVL(S.PARTITION_NAME,'NP') AS PARTITION_NAME
        ,NVL(I.TABLESPACE_NAME,S.TABLESPACE_NAME) AS TABLESPACE_NAME
        ,I.PARTITIONED
        ,ROUND(NVL(S.BYTES,0)/1024/1024,2) SIZE_MB		
        ,ROUND(NVL(S.BYTES,0)/1024/1024/1024,2) SIZE_GB		
        ,ROUND(NVL(S.BYTES,0)/1024/1024/1024/1024,2) SIZE_TB	
  FROM DBA_INDEXES I
  LEFT JOIN DBA_SEGMENTS S		
  ON S.OWNER = I.OWNER 		
  AND S.SEGMENT_NAME = I.INDEX_NAME		
  WHERE I.OWNER = PR_OWNER
  AND I.TABLE_NAME = PR_OBJECT_NAME
  AND NVL(S.PARTITION_NAME,'NP') = PR_PARTITION_NAME
  ORDER BY I.PARTITIONED DESC, 9;  

-- Busca campos LOB
CURSOR C_LOBS (PR_OWNER VARCHAR, PR_OBJECT_NAME VARCHAR, PR_PARTITION_NAME VARCHAR) IS
  SELECT L.OWNER AS LOB_OWNER
        ,L.TABLE_NAME
        ,L.COLUMN_NAME LOB_NAME
  	    ,NVL(S.PARTITION_NAME,'NP') AS PARTITION_NAME		
        ,NVL(L.TABLESPACE_NAME,S.TABLESPACE_NAME) AS TABLESPACE_NAME
        ,L.PARTITIONED
        ,ROUND(NVL(S.BYTES,0)/1024/1024,2) SIZE_MB		
        ,ROUND(NVL(S.BYTES,0)/1024/1024/1024,2) SIZE_GB		
        ,ROUND(NVL(S.BYTES,0)/1024/1024/1024/1024,2) SIZE_TB	
  FROM DBA_TABLES T
  LEFT JOIN DBA_SEGMENTS S		
  ON S.OWNER = T.OWNER 		
  AND S.SEGMENT_NAME = T.TABLE_NAME
  INNER JOIN DBA_LOBS L
  ON S.OWNER = L.OWNER 		
  AND S.SEGMENT_NAME = L.TABLE_NAME
  WHERE L.OWNER = PR_OWNER
  AND L.TABLE_NAME = PR_OBJECT_NAME
  AND NVL(S.PARTITION_NAME,'NP') = PR_PARTITION_NAME
  ORDER BY L.PARTITIONED DESC, 8;

-- Busca dados padrao dos objetos particionados do segmento
CURSOR C_DEF_TS_PART (PR_OWNER VARCHAR, PR_OBJECT_NAME VARCHAR) IS
  SELECT PT.OWNER OWNER_OBJECT
        ,PT.TABLE_NAME NAME_RELATED
        ,PT.TABLE_NAME NAME_OBJECT
        ,PT.DEF_TABLESPACE_NAME
        ,O.OBJECT_TYPE
  FROM DBA_PART_TABLES PT
  INNER JOIN DBA_OBJECTS O
  ON PT.OWNER = O.OWNER
  AND PT.TABLE_NAME = O.OBJECT_NAME
  WHERE PT.OWNER = PR_OWNER
  AND PT.TABLE_NAME = PR_OBJECT_NAME
  AND O.OBJECT_TYPE = 'TABLE'
  UNION
  SELECT PI.OWNER
        ,PI.TABLE_NAME
        ,PI.INDEX_NAME
        ,PI.DEF_TABLESPACE_NAME
        ,O.OBJECT_TYPE
  FROM DBA_PART_INDEXES PI
  INNER JOIN DBA_OBJECTS O
  ON PI.OWNER = O.OWNER
  AND PI.INDEX_NAME = O.OBJECT_NAME
  LEFT JOIN DBA_PART_LOBS PL
  ON PL.TABLE_OWNER = O.OWNER
  AND PL.LOB_INDEX_NAME = O.OBJECT_NAME
  WHERE PI.OWNER = PR_OWNER
  AND PI.TABLE_NAME = PR_OBJECT_NAME
  AND O.OBJECT_TYPE = 'INDEX'
  AND PL.LOB_INDEX_NAME IS NULL
  UNION
  SELECT DISTINCT PL.TABLE_OWNER
                 ,PL.TABLE_NAME
                 ,PL.COLUMN_NAME
                 ,PL.DEF_TABLESPACE_NAME
                 ,'LOB'
  FROM DBA_PART_LOBS PL
  INNER JOIN DBA_OBJECTS O
  ON PL.TABLE_OWNER = O.OWNER
  AND PL.TABLE_NAME = O.OBJECT_NAME
  WHERE PL.TABLE_OWNER = PR_OWNER
  AND PL.TABLE_NAME = PR_OBJECT_NAME
  AND O.OBJECT_TYPE = 'TABLE';

-- Busca dados padrao dos objetos nao particionados do segmento
CURSOR C_DEF_TS_NO_PART (PR_OWNER VARCHAR, PR_OBJECT_NAME VARCHAR) IS
  SELECT T.OWNER OWNER_OBJECT
        ,T.TABLE_NAME NAME_RELATED
        ,T.TABLE_NAME NAME_OBJECT
        ,T.TABLESPACE_NAME
        ,O.OBJECT_TYPE
        ,ROUND(NVL(S.BYTES,0)/1024/1024,2) SIZE_MB		
        ,ROUND(NVL(S.BYTES,0)/1024/1024/1024,2) SIZE_GB		
        ,ROUND(NVL(S.BYTES,0)/1024/1024/1024/1024,2) SIZE_TB	        
  FROM DBA_TABLES T
  INNER JOIN DBA_OBJECTS O
  ON T.OWNER = O.OWNER
  AND T.TABLE_NAME = O.OBJECT_NAME
  INNER JOIN DBA_SEGMENTS S
  ON T.OWNER = S.OWNER
  AND T.TABLE_NAME = S.SEGMENT_NAME  
  WHERE T.OWNER = PR_OWNER
  AND T.TABLE_NAME = PR_OBJECT_NAME
  AND O.OBJECT_TYPE = 'TABLE'
  AND T.PARTITIONED = 'NO'
  UNION  
  SELECT I.OWNER
        ,I.TABLE_NAME
        ,I.INDEX_NAME
        ,I.TABLESPACE_NAME
        ,O.OBJECT_TYPE
        ,ROUND(NVL(S.BYTES,0)/1024/1024,2) SIZE_MB		
        ,ROUND(NVL(S.BYTES,0)/1024/1024/1024,2) SIZE_GB		
        ,ROUND(NVL(S.BYTES,0)/1024/1024/1024/1024,2) SIZE_TB	        
  FROM DBA_INDEXES I
  INNER JOIN DBA_OBJECTS O
  ON I.OWNER = O.OWNER
  AND I.INDEX_NAME = O.OBJECT_NAME
  INNER JOIN DBA_SEGMENTS S
  ON I.OWNER = S.OWNER
  AND I.INDEX_NAME = S.SEGMENT_NAME    
  WHERE I.OWNER = PR_OWNER
  AND I.TABLE_NAME = PR_OBJECT_NAME
  AND O.OBJECT_TYPE = 'INDEX'
  AND I.PARTITIONED = 'NO'    
  UNION
  SELECT DISTINCT L.OWNER
                 ,L.TABLE_NAME
                 ,L.COLUMN_NAME
                 ,L.TABLESPACE_NAME
                 ,'LOB'
                 ,ROUND(NVL(S.BYTES,0)/1024/1024,2) SIZE_MB		
                 ,ROUND(NVL(S.BYTES,0)/1024/1024/1024,2) SIZE_GB		
                 ,ROUND(NVL(S.BYTES,0)/1024/1024/1024/1024,2) SIZE_TB	        
  FROM DBA_LOBS L
  INNER JOIN DBA_OBJECTS O
  ON L.OWNER = O.OWNER
  AND L.TABLE_NAME = O.OBJECT_NAME
  INNER JOIN DBA_SEGMENTS S
  ON L.OWNER = S.OWNER
  AND L.TABLE_NAME = S.SEGMENT_NAME      
  WHERE L.OWNER = PR_OWNER
  AND L.TABLE_NAME = PR_OBJECT_NAME
  AND O.OBJECT_TYPE = 'TABLE'
  AND L.PARTITIONED = 'NO';

-- Busca dados das constraints de relacionamento
CURSOR C_FK (PR_OWNER VARCHAR, PR_OBJECT_NAME VARCHAR) IS
  SELECT C.OWNER CONSTRAINT_OWNER
         ,C.TABLE_NAME
         ,C.CONSTRAINT_NAME
         ,LISTAGG(CC.COLUMN_NAME,', ') COLUMNS_NAME
         ,CR.OWNER OWNER_R
         ,CR.TABLE_NAME TABLE_NAME_R
  FROM DBA_CONSTRAINTS C 
  INNER JOIN DBA_CONS_COLUMNS CC
  ON C.OWNER = CC.OWNER
  AND C.TABLE_NAME = CC.TABLE_NAME
  AND C.CONSTRAINT_NAME = CC.CONSTRAINT_NAME
  INNER JOIN DBA_CONSTRAINTS CR
  ON CR.OWNER = C.R_OWNER
  AND CR.CONSTRAINT_NAME = C.R_CONSTRAINT_NAME 
  WHERE C.OWNER = PR_OWNER
  AND C.TABLE_NAME = PR_OBJECT_NAME
  AND C.CONSTRAINT_TYPE = 'R'
  GROUP BY C.OWNER
        ,C.TABLE_NAME
        ,C.CONSTRAINT_NAME
        ,CR.OWNER
        ,CR.TABLE_NAME; 


BEGIN 
  
  V_INCOMING := '';
  V_DAT_PART := '';
  V_MOVE_TAB := '';
  V_MOVE_IND := '';
  V_MOVE_LOB := '';
  V_REBUILD_IND := '';
  V_COLLECT_TAB := '';
  V_COLLECT_IND := '';
  V_DEF_TSD := '';
  V_DEF_TSI := '';
  V_DEF_TSL := '';
  V_DISABLE_FK := '';
  V_ENABLE_FK := '';
  V_PARAMS := '';
  V_PARAM_COMPRESS := '';
  V_PARAM_UPDATE_INDEX := '';

  
-- Monta parametros adicionais  
  IF P_COMPRESS = 'S' THEN
    V_PARAM_COMPRESS := ' ROW STORE COMPRESS ADVANCED';
  END IF;
  
  IF P_PARALLEL IS NOT NULL THEN
    V_PARAMS := V_PARAMS||' PARALLEL '||TO_CHAR(P_PARALLEL);  
  END IF;  
  
  IF P_ONLINE = 'S' THEN
    V_PARAMS := V_PARAMS||' ONLINE';
  END IF;
  
  IF V_PARAMS IS NOT NULL THEN
    V_PARAMS := V_PARAMS||';'; 
  END IF;
  
  IF P_UPDATE_INDEX = 'S' THEN
    V_PARAM_UPDATE_INDEX := ' UPDATE INDEXES';
  END IF;
  
  DBMS_OUTPUT.PUT_LINE('SET TIMING ON');	  
  DBMS_OUTPUT.PUT_LINE('ALTER SESSION ENABLE PARALLEL DDL;');	  
  DBMS_OUTPUT.PUT_LINE('');	    
  
  
  FOR R16 IN C_OBJECTS LOOP 
  
    -- ALTERA A TABLESPACE PADRAO PARA A TABLESPACE DE DESTINO DOS OBJETOS PARTICIONADOS DA TABELA
    FOR R4 IN C_DEF_TS_PART(R16.SEGMENT_OWNER, R16.SEGMENT_NAME)  LOOP
    
      IF R4.OBJECT_TYPE = 'TABLE' THEN
  
        V_DEF_TSD := 'ALTER TABLE '||R4.OWNER_OBJECT||'.'||R4.NAME_OBJECT||' MODIFY DEFAULT ATTRIBUTES TABLESPACE '||NVL(P_TSDDEST,R4.DEF_TABLESPACE_NAME)||';';
        DBMS_OUTPUT.PUT_LINE(V_DEF_TSD);	
  
      ELSIF R4.OBJECT_TYPE = 'INDEX' AND P_MOVE_INDEX = 'S' THEN
  
        V_DEF_TSI := 'ALTER INDEX '||R4.OWNER_OBJECT||'.'||R4.NAME_OBJECT||' MODIFY DEFAULT ATTRIBUTES TABLESPACE '||NVL(P_TSIDEST,R4.DEF_TABLESPACE_NAME)||';';
        DBMS_OUTPUT.PUT_LINE(V_DEF_TSI);	
  
  	  ELSIF R4.OBJECT_TYPE = 'LOB' AND P_MOVE_LOB = 'S' THEN
  
     	V_DEF_TSL := 'ALTER TABLE '||R4.OWNER_OBJECT||'.'||R4.NAME_RELATED||' MODIFY DEFAULT ATTRIBUTES LOB ('|| R4.NAME_OBJECT ||') (TABLESPACE '||NVL(P_TSLDEST,R4.DEF_TABLESPACE_NAME)||') ROW STORE COMPRESS ADVANCED;';
  	    DBMS_OUTPUT.PUT_LINE(V_DEF_TSL);	
  	
  	  END IF;
  
    END LOOP;
  
    DBMS_OUTPUT.PUT_LINE('');
  	
    -- DESATIVA FKS
    IF P_DISABLE_FK = 'S' THEN
    
      FOR R5 IN C_FK(R16.SEGMENT_OWNER, R16.SEGMENT_NAME) LOOP
  	
  	    V_DISABLE_FK := 'ALTER TABLE '||R5.CONSTRAINT_OWNER||'.'||R5.TABLE_NAME||' DROP CONSTRAINT ' || R5.CONSTRAINT_NAME||';';
  
  	    DBMS_OUTPUT.PUT_LINE(V_DISABLE_FK);	
  	  
  	  END LOOP;
    
    END IF;  
  
    DBMS_OUTPUT.PUT_LINE('');
    
  -- TABELA  
    FOR R1 IN C_TABLES(R16.SEGMENT_OWNER, R16.SEGMENT_NAME)  LOOP
    
      -- VALIDA SE É PARTICIONADA
      IF R1.PARTITIONED = 'YES' THEN
  	
      -- PEGA A DATA DA PARTICAO
      BEGIN
        SELECT HIGH_VALUE 
        INTO V_INCOMING 
        FROM DBA_TAB_PARTITIONS
        WHERE TABLE_OWNER = R1.TABLE_OWNER
          AND TABLE_NAME = R1.TABLE_NAME
          AND PARTITION_NAME = R1.PARTITION_NAME;
          
        V_DAT_PART := SUBSTR(V_INCOMING,11,11);          
          
        EXCEPTION
          WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('--------------------------------');
            DBMS_OUTPUT.PUT_LINE('[ERRO]: ' || TO_CHAR(SQLERRM) || CHR(10) || TO_CHAR(DBMS_UTILITY.FORMAT_ERROR_BACKTRACE));
            DBMS_OUTPUT.PUT_LINE('[TABELA]: ' || R1.TABLE_NAME || CHR(10) || '[PARTICAO]: '|| R1.PARTITION_NAME || CHR(10) ||'[DATA]: '||V_DAT_PART);
            DBMS_OUTPUT.PUT_LINE('--------------------------------');    
          
          WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('--------------------------------');			
            DBMS_OUTPUT.PUT_LINE('[ERRO]: ' || TO_CHAR(SQLERRM) || CHR(10) || TO_CHAR(DBMS_UTILITY.FORMAT_ERROR_BACKTRACE));
            DBMS_OUTPUT.PUT_LINE('--------------------------------');    
      END;    
  	  
  	    -- VALIDA SE A DATA DE PARTICAO ESTÁ DENTRO DA DATA DE CORTE, SE ESTIVER, A PARTICAO TERA COMPRESSAO
        IF TO_DATE(V_DAT_PART,'YYYY-MM-DD') < P_DAT_CORTE_COMPRESS THEN	  
  	    
          V_MOVE_TAB := '-- '||R1.TABLE_NAME||' -- '||R1.PARTITION_NAME||' -- '||V_DAT_PART||' -- '||R1.SIZE_GB||' GB '||CHR(10)||'ALTER TABLE '|| R1.TABLE_OWNER||'.'||R1.TABLE_NAME||' MOVE PARTITION '||R1.PARTITION_NAME||' TABLESPACE '||NVL(P_TSDDEST,R1.TABLESPACE_NAME)||V_PARAM_COMPRESS||V_PARAM_UPDATE_INDEX||V_PARAMS;
   	    
  	    ELSE
  	  
          V_MOVE_TAB := '-- '||R1.TABLE_NAME||' -- '||R1.PARTITION_NAME||' -- '||V_DAT_PART||' -- '||R1.SIZE_GB||' GB '||CHR(10)||'ALTER TABLE '|| R1.TABLE_OWNER||'.'||R1.TABLE_NAME||' MOVE PARTITION '||R1.PARTITION_NAME||' TABLESPACE '||NVL(P_TSDDEST,R1.TABLESPACE_NAME)||V_PARAM_UPDATE_INDEX||V_PARAMS;	  
  	
        END IF;	
  	  
        DBMS_OUTPUT.PUT_LINE(V_MOVE_TAB);	
        
  	    -- MOVE OS CAMPOS LOB	  
  	    IF P_MOVE_LOB = 'S' THEN
  	    
  		  FOR R2 IN C_LOBS(R1.TABLE_OWNER, R1.TABLE_NAME, R1.PARTITION_NAME) LOOP
  	    
            V_MOVE_LOB := '-- '||R1.PARTITION_NAME||' -- '||R2.SIZE_GB||' GB '||CHR(10)||'ALTER TABLE '|| R2.LOB_OWNER||'.'||R2.TABLE_NAME||' MOVE PARTITION '||R1.PARTITION_NAME||' LOB('||R2.LOB_NAME||') STORE AS (TABLESPACE '||NVL(P_TSLDEST,R2.TABLESPACE_NAME)||')'||V_PARAM_COMPRESS||V_PARAM_UPDATE_INDEX||V_PARAMS;
          
  		    DBMS_OUTPUT.PUT_LINE(V_MOVE_LOB);	
  	    
  	      END LOOP;
  	  
        END IF;
  
        -- MOVE INDICES
  	    IF P_MOVE_INDEX = 'S' THEN
  	  
          IF P_UPDATE_INDEX = 'N' THEN
  	    
            FOR R3 IN C_INDEXES(R1.TABLE_OWNER, R1.TABLE_NAME, R1.PARTITION_NAME) LOOP
  	        
    	      -- VALIDA SE A DATA DE PARTICAO ESTÁ DENTRO DA DATA DE CORTE, SE ESTIVER, O INDICE TERA COMPRESSAO
              IF TO_DATE(V_DAT_PART,'YYYY-MM-DD') < P_DAT_CORTE_COMPRESS THEN	  
			
                V_MOVE_IND := '-- '||R3.INDEX_NAME||' -- '||R3.PARTITION_NAME||' -- '||R3.SIZE_GB||' GB '||CHR(10)||'ALTER INDEX '||R3.INDEX_OWNER||'.'||R3.INDEX_NAME||' REBUILD PARTITION '||R3.PARTITION_NAME||' COMPRESS ADVANCED TABLESPACE '||NVL(P_TSIDEST,R3.TABLESPACE_NAME)||V_PARAMS;
 	    
	          ELSE
	  
                V_MOVE_IND := '-- '||R3.INDEX_NAME||' -- '||R3.PARTITION_NAME||' -- '||R3.SIZE_GB||' GB '||CHR(10)||'ALTER INDEX '||R3.INDEX_OWNER||'.'||R3.INDEX_NAME||' REBUILD PARTITION '||R3.PARTITION_NAME||' TABLESPACE '||NVL(P_TSIDEST,R3.TABLESPACE_NAME)||V_PARAMS;
	
              END IF;	
            
  		      DBMS_OUTPUT.PUT_LINE(V_MOVE_IND);	
  	      
  	        END LOOP;
  	    
  	      END IF; 
  		
        END IF; 	 
  
  	    DBMS_OUTPUT.PUT_LINE('');		  
  	  
  
  	  ELSE -- TABELAS NAO PARTICIONADAS
  	
  	    V_MOVE_TAB := '-- '||R1.TABLE_NAME||' -- '||R1.SIZE_GB||' GB '||CHR(10)||'ALTER TABLE '|| R1.TABLE_OWNER||'.'||R1.TABLE_NAME||' MOVE TABLESPACE '||NVL(P_TSDDEST,R1.TABLESPACE_NAME)||V_PARAM_UPDATE_INDEX||V_PARAMS;
  
  	    DBMS_OUTPUT.PUT_LINE(V_MOVE_TAB);	
  	  
        DBMS_OUTPUT.PUT_LINE('');		  
  
  	    -- MOVE OS CAMPOS LOB	  
  	    IF P_MOVE_LOB = 'S' THEN
  	    
  		  FOR R10 IN C_LOBS(R1.TABLE_OWNER, R1.TABLE_NAME, R1.PARTITION_NAME) LOOP
  	    
            V_MOVE_LOB := '-- '||R10.TABLE_NAME||' -- '||R10.SIZE_GB||' GB '||CHR(10)||'ALTER TABLE '|| R10.LOB_OWNER||'.'||R10.TABLE_NAME||' MOVE LOB('||R10.LOB_NAME||') STORE AS (TABLESPACE '||NVL(P_TSLDEST,R10.TABLESPACE_NAME)||')'||V_PARAM_COMPRESS||V_PARAM_UPDATE_INDEX||V_PARAMS;
           
  		    DBMS_OUTPUT.PUT_LINE(V_MOVE_LOB);	
  	    
  	      END LOOP;
  	  
        END IF;
  	
  	  END IF;
    
    END LOOP; -- TABELAS

    -- RECONSTROI OS INDICES GLOBAIS
	IF P_UPDATE_INDEX = 'N' THEN
	
      FOR R7 IN C_DEF_TS_NO_PART(R16.SEGMENT_OWNER, R16.SEGMENT_NAME) LOOP
	  
        IF R7.OBJECT_TYPE = 'INDEX' THEN
      
          V_REBUILD_IND := '-- '||R7.NAME_OBJECT||' -- '||R7.SIZE_GB||' GB '||CHR(10)||'ALTER INDEX '||R7.OWNER_OBJECT||'.'||R7.NAME_OBJECT||' REBUILD TABLESPACE '||NVL(P_TSIDEST,R7.TABLESPACE_NAME)||V_PARAMS;
      
          DBMS_OUTPUT.PUT_LINE(V_REBUILD_IND);		 
	  
        END IF;
  	    
      END LOOP;
	
	END IF;
  
    DBMS_OUTPUT.PUT_LINE('');	
  	
    -- RETIRA PARALELISMO
    IF P_PARALLEL > 0 THEN
    
      FOR R8 IN C_DEF_TS_PART(R16.SEGMENT_OWNER, R16.SEGMENT_NAME) LOOP
    
        IF R8.OBJECT_TYPE = 'TABLE' THEN
  	  
          V_DEF_TSD := 'ALTER TABLE '||R8.OWNER_OBJECT||'.'||R8.NAME_OBJECT||' NOPARALLEL;';
          DBMS_OUTPUT.PUT_LINE(V_DEF_TSD);	
  	  
        ELSIF R8.OBJECT_TYPE = 'INDEX' THEN
  	  
          V_DEF_TSI := 'ALTER INDEX '||R8.OWNER_OBJECT||'.'||R8.NAME_OBJECT||' NOPARALLEL;';
          DBMS_OUTPUT.PUT_LINE(V_DEF_TSI);	
  	  
  	    END IF;
  
      END LOOP;
   
      FOR R9 IN C_DEF_TS_NO_PART(R16.SEGMENT_OWNER, R16.SEGMENT_NAME) LOOP
    
        IF R9.OBJECT_TYPE = 'TABLE' THEN
  	  
          V_DEF_TSD := 'ALTER TABLE '||R9.OWNER_OBJECT||'.'||R9.NAME_OBJECT||' NOPARALLEL;';
          DBMS_OUTPUT.PUT_LINE(V_DEF_TSD);	
  	  
        ELSIF R9.OBJECT_TYPE = 'INDEX' THEN
  	  
          V_DEF_TSI := 'ALTER INDEX '||R9.OWNER_OBJECT||'.'||R9.NAME_OBJECT||' NOPARALLEL;';
          DBMS_OUTPUT.PUT_LINE(V_DEF_TSI);	
  	  
  	    END IF;
  
      END LOOP;
  
    END IF;
    
    DBMS_OUTPUT.PUT_LINE('');  
    
    -- ATIVA FKS DEPOIS DE TUDO EXECUTADO
    IF P_DISABLE_FK = 'S' THEN
    
      FOR R6 IN C_FK(R16.SEGMENT_OWNER, R16.SEGMENT_NAME)  LOOP
	  
  	    V_ENABLE_FK := 'ALTER TABLE '||R6.CONSTRAINT_OWNER||'.'||R6.TABLE_NAME||' ADD CONSTRAINT ' || R6.CONSTRAINT_NAME||' FOREIGN KEY ('||R6.COLUMNS_NAME||') REFERENCES '||R6.OWNER_R||'.'||R6.TABLE_NAME_R||'('||R6.COLUMNS_NAME||') ENABLE NOVALIDATE;';
  
  	    DBMS_OUTPUT.PUT_LINE(V_ENABLE_FK);	
  	  
	  END LOOP;
    
    END IF;
  
    DBMS_OUTPUT.PUT_LINE('');  
    
    -- COLETA ESTATISTICAS
    IF P_COLLECT_STATS = 'S' THEN
    
      FOR R11 IN C_TABLES(R16.SEGMENT_OWNER, R16.SEGMENT_NAME)  LOOP
  	
  	    IF R11.PARTITIONED = 'YES' THEN
  	  
  	      V_COLLECT_TAB := 'EXEC DBMS_STATS.GATHER_TABLE_STATS( OWNNAME=>'''|| R11.TABLE_OWNER||''', TABNAME=>'''||R11.TABLE_NAME||''', PARTNAME=>'''||R11.PARTITION_NAME||''', ESTIMATE_PERCENT => dbms_stats.auto_sample_size, DEGREE => '||TO_CHAR(P_PARALLEL)||', GRANULARITY => ''AUTO'', NO_INVALIDATE => TRUE ); ';
  	  
  	    ELSE
  	  
  	      V_COLLECT_TAB := 'EXEC DBMS_STATS.GATHER_TABLE_STATS( OWNNAME=>'''|| R11.TABLE_OWNER||''', TABNAME=>'''||R11.TABLE_NAME||''', ESTIMATE_PERCENT => dbms_stats.auto_sample_size, DEGREE => '||TO_CHAR(P_PARALLEL)||', GRANULARITY => ''AUTO'', NO_INVALIDATE => TRUE ); ';
  		
  	    END IF;
  	
        DBMS_OUTPUT.PUT_LINE(V_COLLECT_TAB);	
  	  
        FOR R12 IN C_INDEXES(R11.TABLE_OWNER, R11.TABLE_NAME, R11.PARTITION_NAME) LOOP
  	
     	  IF R12.PARTITIONED = 'YES' THEN
     	    
     	    V_COLLECT_IND := 'EXEC DBMS_STATS.GATHER_INDEX_STATS( OWNNAME=>'''|| R12.INDEX_OWNER||''', INDNAME=>'''||R12.INDEX_NAME||''', PARTNAME=>'''||R12.PARTITION_NAME||''', ESTIMATE_PERCENT => dbms_stats.auto_sample_size, DEGREE => '||TO_CHAR(P_PARALLEL)||', GRANULARITY => ''AUTO'', NO_INVALIDATE => TRUE ); ';
     	    	   
     	  ELSE
     	    
     	    V_COLLECT_IND := 'EXEC DBMS_STATS.GATHER_INDEX_STATS( OWNNAME=>'''|| R12.INDEX_OWNER||''', INDNAME=>'''||R12.INDEX_NAME||''', ESTIMATE_PERCENT => dbms_stats.auto_sample_size, DEGREE => '||TO_CHAR(P_PARALLEL)||', GRANULARITY => ''AUTO'', NO_INVALIDATE => TRUE ); ';
     		  
     	  END IF;
  	    
     	  DBMS_OUTPUT.PUT_LINE(V_COLLECT_IND);	
     	
     	END LOOP;
  	  
  	  END LOOP;
  
      DBMS_OUTPUT.PUT_LINE('');	
  		  
      FOR R15 IN C_DEF_TS_NO_PART(R16.SEGMENT_OWNER, R16.SEGMENT_NAME) LOOP
    
        IF R15.OBJECT_TYPE = 'INDEX' THEN
  	  
          V_COLLECT_IND := 'EXEC DBMS_STATS.GATHER_INDEX_STATS( OWNNAME=>'''|| R15.OWNER_OBJECT||''', INDNAME=>'''||R15.NAME_OBJECT||''', ESTIMATE_PERCENT => dbms_stats.auto_sample_size, DEGREE => '||TO_CHAR(P_PARALLEL)||', GRANULARITY => ''AUTO'', NO_INVALIDATE => TRUE ); ';      
      	  DBMS_OUTPUT.PUT_LINE(V_COLLECT_IND);	
  	  
  	    END IF;
  
      END LOOP;	
  	
    END IF;  
	
  END LOOP;  -- SEGMENTOS
END;
/
SHOW ERRORS